\begin{command}[@FWR/algorithmCfloat]{algorithmCfloat}	\desc{Purpose}Return the algorithm associated to this realization.The algorithm is written in C-code with float	\desc{Syntax}\matlab{code = algorithmCfloat( R, funcName)}	\desc{Parameters}		\begin{tabular}{l@{\ :\ }p{9cm}}\matlab{code} &  resulting C-code (with float)                  \\\matlab{R} &  FWR object                                        \\\matlab{funcName} &  name of the C-function (default=\matlab{myFilter})\\		\end{tabular}	\desc{Description}Transform in \texttt{C}-code with \texttt{float} the algorithm of the realization:\begin{align*}&\text{[i]} & JT(k+1) & \leftarrow MX(k) + NU(k)\\&\text{[ii]} & X(k+1)  & \leftarrow KT(k+1) + PX(k) + QU(k)\\&\text{[iii]} & Y(k)    & \leftarrow LT(k+1) + RX(k) + SU(k)\end{align*}All the operations with matrices are expanded, and null multiplications are removed, identity multiplications are simplified, etc.\\The input or a pointer to the vector of inputs is given to the function. The function returns the output or a pointer to a vector of putputs.\\The intermediate variables are stored in a variable \matlab{T}. The states are stored in \matlab{static} variables \matlab{xn} and \matlab{xnp} (\matlab{xnp} is not necessary if $P$ is upper triangular), and a permutation of the vector (a permutation of the pointer to the vector) is performed for the next call.	\desc{Example}\begin{lstlisting}[language=C]>> algorithmCfloat(R)ans =float myFilter( float u){// statesstatic float* xn = (float*) calloc( 8*sizeof(float));// intermediate variablesfloat T = -0.6630104844*xn[0] + 2.9240526562*xn[1] + -4.8512758825*xn[2]+ 3.5897338871*xn[3] + 0.0000312390*xn[4] + 0.0001249559*xn[5]+ 0.0001874339*xn[6] + 0.0001249559*xn[7] + 0.0000312390*u    ;// output(s)y = T    ;// statesxn[0] = xn[1];xn[1] = xn[2];xn[2] = xn[3];xn[3] = T    ;xn[4] = xn[5];xn[5] = xn[6];xn[6] = xn[7];xn[7] = u    ;}\end{lstlisting}\desc{See also}\funcName[@FWR/algorithmLaTeX]{algorithmLaTeX}\end{command}