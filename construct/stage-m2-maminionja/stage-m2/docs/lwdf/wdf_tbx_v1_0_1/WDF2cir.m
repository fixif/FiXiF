function Coeffs = WDF2cir(WDF,dlyLorR,cirFilename)
%WDF2CIR	Writes the WDF structure as a .cir description for scheduling
%	Coeffs = WDF2CIR(WDF,dlyLorR,cirFilename) converts the structure in WDF (WDF.wdaStruct)
%	in the .cir format used by the scheduling functions and writes it to cirFilename.
%	dlyLorR should be an 'L' or 'R' and specifies the location of the delay when 2-port
%	adaptors are used in the top row (resp. in the left or the rightmost connection,
%	defaults to 'L'). 
%	If cirFilename is not specified, output is written to the command window.
%	In the cell-array Coeffs, the operation names assigned in the cir file are linked 
%	to the multiplication constants (WDF.mulFacs) of WDF, and corrected or extended
%	if needed.
%
% 	See also LADDER2WDF, SHOWWDF, LWDF2CIR.

% (c) H.J. Lincklaen Arriens, 
%     Delft University of Technology, September 2005
%									  Feb 2006, added dlyLorR possibility

% still an omission:
% CHECK FOR VALID WDF structure, numbers and mulFacs ???


if ( nargin < 3 )  
	fid = 1;
else
	fid = fopen(cirFilename,'w');
	% SHOULD BE: TEST FOR EXISTING ONE AND, IF SO, ASK PERMISSION TO OVERWRITE
	if ( fid == -1 )
		error( 'Cannot create file "%s" ...', cirFilename );
	end  
end
if ( nargin < 2 )
	dlyLorR = 'L';
else
	dlyLorR = upper(dlyLorR);
	if ~( (dlyLorR == 'L') || (dlyLorR == 'R') )
		error( 'WDF2cir syntax error: dlyLorR should be ''L'' or ''R'' ...' );
	end
end

wdaCodes = WDF.wdaStruct;
wdaNo	 = WDF.wdaNo;
mulFacs  = WDF.mulFacs;
for i = 1:length(mulFacs)
	tmpCoeffs(i,:) = [ {'xxx'}  mulFacs(i) ]; 
end
if ( wdaCodes(2,end) == 'm' )
	wdaCodes = wdaCodes(:,1:end-1);
	wdaNo    = wdaNo(:,1:end-1);
	mulFacB3 = mulFacs(end);
else
	mulFacB3 = 1;
end
wdaChar = char( wdaNo + '@' );
nSlices = size( wdaCodes, 2 );


% test for an asymmetric or a symmetric structure of the 3-ports in the bottom row
% This information has been passed by means of WDF.wdaStruct (== wdaCodes), e.g.
% symmetric: psPsp (P or S in the middle), while asymmetric: pspsP (..at end) 
nPasses    = 1;
passLength = nSlices;
midSliceNo = nSlices +1;				% and set index past last slice 
if ( rem(nSlices,2) ~= 0 )
	testSliceNo = (nSlices+1)/2;
	if ( wdaCodes(2,testSliceNo) < 'a' )	% 'S' and 'P' are < 'a';  's','p' > 'a'	
		midSliceNo = testSliceNo;
		nPasses    = 2;
		passLength = [ midSliceNo - 1; midSliceNo ];
	end
end

fprintf( fid, '%% Wave Digital Filter structure.\n' );
fprintf( fid, '%% Code generated by WDF2cir.m on %s.\n\n', datestr(clock) );
fprintf( fid, '%% external input ''inp'', external outputs ''o_fwd'' and ''o_rev''\n\n\n' );

% ???? NOG IETS AAN ERROR MESSAGE INDICES DOEN OF INDERDAAD : 
%   AAN BEGIN CHECKEN EN HIER NIET MEER
iSlice  = 0;
a00Flag = 0;
orgWdaChar = wdaChar;
for thisPass = 1:nPasses
	if ( thisPass == 2 )
		wdaChar = fliplr(wdaChar);
		B3left  = B3Str;
		iSlice  = nSlices +1; 
	end
	double_s = 0;
	double_p = 0;

	for i = 1:passLength(thisPass)
		topWdaType  = wdaCodes(1,i);
		thisWdaType = wdaCodes(2,i);
		thisWdaChar = wdaChar(2,i);
		if ( thisPass == 1 )
			iSlice = iSlice +1;
		else
			iSlice = iSlice -1;
		end
		switch thisWdaType
			case 's'
				B2Str = 'v3';
			case 'S'
				B2Str = 'v5';
			case {'p','P'}
				B2Str = 'v4';
		end
		switch topWdaType
			case '+'
				fprintf( fid, '%% "+" in top row\n' );
				A2Str = lfT(fid,thisWdaChar,[B2Str thisWdaChar]);
			case '-'
				fprintf( fid, '%% "-" in top row\n' );
				A2Str = lfT(fid,thisWdaChar,[B2Str thisWdaChar]);
			case 's'
				A2Str = lfTop3pSerRF(fid,wdaChar(1,i),[B2Str thisWdaChar]);
			case 'p'
				A2Str = lfTop3pParRF(fid,wdaChar(1,i),[B2Str thisWdaChar]);
			case 'S'
				if ( dlyLorR == 'L' )
					A2Str = lfTop2pSer_TL(fid,wdaChar(1,i),B2Str,thisWdaChar);
				else
					A2Str = lfTop2pSer_TR(fid,wdaChar(1,i),B2Str,thisWdaChar);
				end
			case 'P'
				if ( dlyLorR == 'L' )
					A2Str = lfTop2pPar_TL(fid,wdaChar(1,i),B2Str,thisWdaChar);
				else
					A2Str = lfTop2pPar_TR(fid,wdaChar(1,i),B2Str,thisWdaChar);
				end				
		end
		if ( (lower(topWdaType) == 's') || (lower(topWdaType) == 'p') )
			aIx = wdaNo(1,iSlice);
			if ( (thisPass == 2) && (i ~= midSliceNo) )	% two coeffs in lower middle adaptor
				aIx = aIx +1;
			end
			tmpCoeffs(aIx,1) = { sprintf( 'a1%s', orgWdaChar(1,iSlice) ) };
		end
	% special: first adaptor
		if ( i == 1 )
			if ( thisPass == 1)
				if ( thisWdaType == 's' )
					A3Str = [ 'v2' wdaChar(2,i+1) ];	% B1Str from next wda, should be a 'p'
					if ( topWdaType ~= '-' )
						B3Str = lf_s1m_pip_pii(fid,thisWdaChar,'inp',A2Str,A3Str);
					else
						B3Str = lf_s1m_ppp_pii(fid,thisWdaChar,'inp',A2Str,A3Str);
					end
					fprintf( fid, '\no_rev = v1%s;\n', thisWdaChar ); 
				else
					% obviously a 'p' then
					A3Str = [ 'v1' wdaChar(2,i+1) ];	% B1Str from next wda, should be an 's'
					if ( topWdaType ~= '-' )
						B3Str = lf_p1m_ppp_ipp(fid,thisWdaChar,'inp',A2Str,A3Str);
					else
						B3Str = lf_p1m_ppp_iip(fid,thisWdaChar,'inp',A2Str,A3Str);
					end
					fprintf( fid, '\no_rev = v2%s;\n', thisWdaChar ); 
				end
				tmpCoeffs(wdaNo(2,1),1) = { sprintf( 'a1%s', thisWdaChar ) };
			else		% thisPass == 2: symmetrical, wda is "end"-one with A1=0, 
						% because of symmetry, m3 limited to +/- 1.0
				if ( thisWdaType == 's' )
					if ( wdaCodes(2,i+1) == 'P' )  % only 3 Slices
						A3Str = [ 'v6' wdaChar(2,i+1) ];		% B3Str from next wda: P
					else
						A3Str = [ 'v2' wdaChar(2,i+1) ];		% B1Str from next wda, p
					end
					if ( topWdaType ~= '-' )
						if ( mulFacB3 == 1.0 )
							[B1Str,B3Str] = lf_s1m_0pp_ppi(fid,thisWdaChar,'a00',A2Str,A3Str);
							a00Flag = 1;
						else
							[B1Str,B3Str] = lf_s1m_0pp_ipi(fid,thisWdaChar,A2Str,A3Str);
						end
					else
						if ( mulFacB3 == 1.0 )
							[B1Str,B3Str] = lf_s1m_0pp_pii(fid,thisWdaChar,'a00',A2Str,A3Str);
							a00Flag = 1;
						else
							[B1Str,B3Str] = lf_s1m_0pp_iii(fid,thisWdaChar,A2Str,A3Str);
						end
					end
				else 
					if ( wdaCodes(2,i+1) == 'S' )  % only 3 Slices
						A3Str = [ 'v6' wdaChar(2,i+1) ];		% B3Str from next wda: S
					else
						A3Str = [ 'v1' wdaChar(2,i+1) ];		% B1Str from next wda, s
					end
					if ( topWdaType ~= '-' )
						if ( mulFacB3 == 1.0 )
							[B1Str,B3Str] = lf_p1m_0pp_ppp(fid,thisWdaChar,A2Str,A3Str);
						else
							[B1Str,B3Str] = lf_p1m_0pp_ipp(fid,thisWdaChar,'a00',A2Str,A3Str);
							a00Flag = 1;
						end
					else
						if ( mulFacB3 == 1.0 )
							[B1Str,B3Str] = lf_p1m_0pp_pip(fid,thisWdaChar,A2Str,A3Str);
						else
							[B1Str,B3Str] = lf_p1m_0pp_iip(fid,thisWdaChar,A2Str,A3Str);
						end
					end
				end
				fprintf( fid, '\no_fwd = %s;\n', B1Str );
				tmpCoeffs(wdaNo(2,nSlices)+1,1) = { sprintf( 'a1%s', thisWdaChar ) };
				if ( mulFacB3 == -1.0 )
					tmpCoeffs = tmpCoeffs(1:end-1,:);
				end;
			end		% thisPass
		end			% if ( i == 1 )

	% adaptor in non-symmetrical chain or else left from middle one, not last one
		if ( ( i ~= 1 ) && (i < midSliceNo) && (i < nSlices) )
			if ( thisWdaType == 's' )
				switch wdaCodes(2,i+1)
					case 'p'
						A3Str = [ 'v2' wdaChar(2,i+1) ];
					case 'P'
						if ( thisPass == 1 )
							A3Str = [ 'v2' wdaChar(2,i+1) ];
						else
							A3Str = [ 'v6' wdaChar(2,i+1) ];
						end
					case 's'
						A3Str = [ 'v1' wdaChar(2,i+1) ];
						double_s = 1;	% thisWda is the first of 2 sequential s1m's
				end
				if ( double_s ~= 1 )	% single s1m or the 2nd of two sequential s1m's
					if ( topWdaType ~= '-' )
						B3Str = lf_s1m_pip_pii(fid,thisWdaChar,B3Str,A2Str,A3Str);
					else				% the next one only if -T, single s1m
						B3Str = lf_s1m_ppp_pii(fid,thisWdaChar,B3Str,A2Str,A3Str);
					end
				else	% 1st of "double_s"
					B3Str = lf_s1m_pip_pip(fid,thisWdaChar,B3Str,A2Str,A3Str);
				end
				double_s = 0;
				double_p = 0;
			else
				% obviously a 'p' then
				switch wdaCodes(2,i+1)
					case 's'
						A3Str = [ 'v1' wdaChar(2,i+1) ];
					case 'S'
						if ( thisPass == 1 )
							A3Str = [ 'v1' wdaChar(2,i+1) ];
						else
							A3Str = [ 'v6' wdaChar(2,i+1) ];
						end
					case 'p'
						A3Str = [ 'v2' wdaChar(2,i+1) ];
				end
				if ( double_p ~= 1 )
					if ( topWdaType ~= '-' )
						B3Str = lf_p1m_ipp_ppp(fid,thisWdaChar,B3Str,A2Str,A3Str);
					else
						B3Str = lf_p1m_ipp_pip(fid,thisWdaChar,B3Str,A2Str,A3Str);
					end
				else	% 2nd p1m
					B3Str = lf_p1m_ppp_ppp(fid,thisWdaChar,B3Str,A2Str,A3Str);
				end
				double_s = 0;
				double_p = double_p + 1;
			end
			aIx = wdaNo(2,iSlice);
			if ( (thisPass == 2) && (i ~= midSliceNo) )		% two coeffs in lower middle adaptor
				aIx = aIx +1;
			end
			tmpCoeffs(aIx,1) = { sprintf( 'a1%s', orgWdaChar(2,iSlice) ) };
		end

	% rightmost adaptor, input = zero 
		if ( i == nSlices ) % <<<<<< 
			switch thisWdaType
				case 'S'
					if ( mulFacB3 == -1.0 )
						if ( topWdaType ~= '-' )
							[B3Str,a3Sign] = lf_S2m_pi0_pii(fid,thisWdaChar,B3Str,A2Str);
						else
							[B3Str,a3Sign] = lf_S2m_pp0_pii(fid,thisWdaChar,B3Str,A2Str);
						end
					else	% positive including +1.0
						if ( topWdaType ~= '-' )
							[B3Str,a3Sign] = lf_S2m_pi0_pip(fid,thisWdaChar,B3Str,A2Str);
						else
							[B3Str,a3Sign] = lf_S2m_pp0_pip(fid,thisWdaChar,B3Str,A2Str);
						end
					end
				case 'P'
					a3Sign = '+';
					if ( mulFacB3 == -1.0 )
						if ( topWdaType ~= '-' )
							B3Str = lf_P2m_ii0_pii(fid,thisWdaChar,B3Str,A2Str);
						else
							B3Str = lf_P2m_ip0_pii(fid,thisWdaChar,B3Str,A2Str);
						end
					else	% positive including +1.0
						if ( topWdaType ~= '-' )
							B3Str = lf_P2m_ip0_ppp(fid,thisWdaChar,B3Str,A2Str);
						else
							B3Str = lf_P2m_ii0_ppp(fid,thisWdaChar,B3Str,A2Str);
						end
					end
			end
			if ( abs(mulFacB3) == +1.0 )
				fprintf( fid, '\no_fwd = %s;\n', B3Str );
			else
				fprintf( fid, '\nm3o = %s * a_m3\n', B3Str );
				fprintf( fid, 'o_fwd = m3o;\n' );
				tmpCoeffs(end,1) = {'a_m3'}; 
			end
			aIx = wdaNo(2,nSlices);
			tmpCoeffs(aIx,1) = { sprintf( 'a1%s', thisWdaChar ) };
			if ( a3Sign == '+' )
				tmpCoeffs(aIx+1,1) = { sprintf( 'a3%s', thisWdaChar ) };
			else
				tmpCoeffs(aIx+1,1) = { sprintf( 'a3n%s', thisWdaChar ) };
				tmpCoeffs(aIx+1,2) = { -cell2mat(tmpCoeffs(aIx+1,2)) };
			end
		else
			% symmetrical structure: middle adaptor
			if ( (thisPass == 2) && (i == midSliceNo) )
				switch thisWdaType
					case 'S'
						if ( topWdaType ~= '-' )
							lf_S2m_pip_pip(fid,thisWdaChar,B3left,A2Str,B3Str);
						else
							lf_S2m_ppp_pip(fid,thisWdaChar,B3left,A2Str,B3Str);
						end
					case 'P'
						if ( topWdaType ~= '-' )
							lf_P2m_ipi_ppp(fid,thisWdaChar,B3left,A2Str,B3Str);
						else
							lf_P2m_ipi_pip(fid,thisWdaChar,B3left,A2Str,B3Str);
						end
				end
				aIx = wdaNo(2,midSliceNo);
				tmpCoeffs(aIx,1)   = { sprintf( 'a1%s', orgWdaChar(2,midSliceNo) ) };
				tmpCoeffs(aIx+1,1) = { sprintf( 'a3%s', orgWdaChar(2,midSliceNo) ) };
			end		
		end
		fprintf( fid, '\n' );
	end		% for i

end			% for thisPass

fprintf( fid, '\n%% (c) HJLA, 2005\n%% [EOF]\n' );
if ( fid ~= 1 )
	fclose(fid);
end
%==========================================================================
% NOTE:  for 2-ports: coeffs(x) is Nouta's "alpha1"   NOTE  NOTE  NOTE !!
%        The cir-description uses the correct structure and takes care for
%        the necessary - operation.
%==========================================================================
if ( a00Flag == 1 )
	Coeffs = [ [{'a00'} {0.0}]; tmpCoeffs ];
else
	Coeffs = tmpCoeffs;
end


%==========================================================================================
%=========  LOCAL FUNCTIONS  ======  LOCAL FUNCTIONS  ======  LOCAL FUNCTIONS  ============
%==========================================================================================

% delay + or -T in top row (sign is taken care of by adaptor in bottom row)
function A2Str = lfT(fid,wdaChar,inpStr)
	fprintf( fid, 'o1%s = %s;\n', wdaChar, inpStr );
	A2Str = sprintf( 'i1%s', wdaChar );
	fprintf( fid, '%s = To1%s;\n', A2Str, wdaChar );
	
% 3-port serial in top row, reflection free, with T and -T
function B3Str = lfTop3pSerRF(fid,wdaChar,A3Str)
	fprintf( fid, '%% top row 3p adaptor, reflection free, with T and -T\n' );
	fprintf( fid, 'v1%s = i1%s - m1%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v2%s = i1%s + i2%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v3%s = v1%s - %s;\n', wdaChar, wdaChar, A3Str );		% <<<<<<<<<<
	fprintf( fid, 'v4%s = v2%s - %s;\n', wdaChar, wdaChar, A3Str );		% <<<<<<<<<< 
	fprintf( fid, 'm1%s = a1%s * v4%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'o1%s = v1%s;\n', wdaChar, wdaChar ); 
	fprintf( fid, 'o2%s = v3%s;\n', wdaChar, wdaChar ); 
	fprintf( fid, 'i1%s = To1%s;\n', wdaChar, wdaChar );  
	fprintf( fid, 'i2%s = To2%s;\n', wdaChar, wdaChar );
	B3Str = sprintf( 'v2%s', wdaChar );  	% -B3   

% 3-port parallel in top row, reflection free, with T and -T
function B3Str = lfTop3pParRF(fid,wdaChar,A3Str)
	fprintf( fid, '%% top row 3p adaptor, reflection free, with T and -T\n' );
	fprintf( fid, 'v1%s = i1%s + i2%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v2%s = v4%s - v1%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v3%s = i2%s - m1%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v4%s = m1%s - %s;\n', wdaChar, wdaChar, A3Str );		% <<<<<<<<<<
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'o1%s = v2%s;\n', wdaChar, wdaChar ); 
	fprintf( fid, 'o2%s = v4%s;\n', wdaChar, wdaChar ); 
	fprintf( fid, 'i1%s = To1%s;\n', wdaChar, wdaChar );  
	fprintf( fid, 'i2%s = To2%s;\n', wdaChar, wdaChar );
	B3Str = sprintf( 'v3%s', wdaChar );  	% -B3 

%==========================================================================================
%     IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT 
%  Descriptions of 2-port structure using "-alpha1"   ( == 1 - alpha !!! )
%  WDF.mulFacs for 2-ports is "alpha1"  -->  the code below accounts for the - ooperation
%     IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT 
%==========================================================================================
% 2-port in top row, translation of serial resonator (S) with two T's
% delay T at input left
function B1Str = lfTop2pSer_TL(fid,wdaChar,A1Str,fromWdaChar)
	fprintf( fid, '%% top row 2p adaptor, serial resonator\n' );
	fprintf( fid, 'o1%s = %s;\n', fromWdaChar, [A1Str fromWdaChar] );
	fprintf( fid, 'i1%s = To1%s;\n', wdaChar, fromWdaChar );
	fprintf( fid, 'v1%s = i2%s - i1%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v2%s = i2%s - m1%s;\n', wdaChar, wdaChar, wdaChar );	% struct "a"
	fprintf( fid, 'o2%s = v2%s;\n', wdaChar, wdaChar );
	fprintf( fid, 'i2%s = To2%s;\n', wdaChar, wdaChar );
	fprintf( fid, 'v3%s = v1%s + v2%s;\n', wdaChar, wdaChar, wdaChar );	% struct "a"
	B1Str = sprintf( 'v3%s', wdaChar );

% 2-port in top row, translation of serial resonator (S) with two T's
% delay T Tat output right
function B1Str = lfTop2pSer_TR(fid,wdaChar,A1Str,lowWdaChar)
	fprintf( fid, '%% top row 2p adaptor, serial resonator\n' );
	fprintf( fid, 'v1%s = i2%s - %s;\n', wdaChar, wdaChar, [A1Str lowWdaChar]);
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v2%s = i2%s - m1%s;\n', wdaChar, wdaChar, wdaChar );	% struct "a"
	fprintf( fid, 'o2%s = v2%s;\n', wdaChar, wdaChar );
	fprintf( fid, 'i2%s = To2%s;\n', wdaChar, wdaChar );
	fprintf( fid, 'v3%s = v1%s + v2%s;\n', wdaChar, wdaChar, wdaChar );	% struct "a"
	fprintf( fid, 'o1%s = v3%s;\n', wdaChar, wdaChar );
	fprintf( fid, 'i1%s = To1%s;\n', lowWdaChar, wdaChar );
	B1Str = sprintf( 'i1%s', lowWdaChar );

% 2-port in top row, translation of parallel resonator (P) with T and -T
% delay T at input left
function B1Str = lfTop2pPar_TL(fid,wdaChar,A1Str,fromWdaChar)
	fprintf( fid, '%% top row 2p adaptor, parallel resonator\n' );
	fprintf( fid, 'o1%s = %s;\n', fromWdaChar, [A1Str fromWdaChar] );
	fprintf( fid, 'i1%s = To1%s;\n', wdaChar, fromWdaChar );
	fprintf( fid, 'v1%s = i2%s - i1%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v2%s = m1%s - i2%s;\n', wdaChar, wdaChar, wdaChar );	% struct "a"
	fprintf( fid, 'o2%s = v2%s;\n', wdaChar, wdaChar );
	fprintf( fid, 'i2%s = To2%s;\n', wdaChar, wdaChar );
	fprintf( fid, 'v3%s = v1%s - v2%s;\n', wdaChar, wdaChar, wdaChar );	% struct "a"
	B1Str = sprintf( 'v3%s', wdaChar );

% 2-port in top row, translation of parallel resonator (P) with T and -T
% delay T at output right
function B1Str = lfTop2pPar_TR(fid,wdaChar,A1Str,lowWdaChar)
	fprintf( fid, '%% top row 2p adaptor, parallel resonator\n' );
	fprintf( fid, 'v1%s = i2%s - %s;\n', wdaChar, wdaChar, [A1Str lowWdaChar]);
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v2%s = m1%s - i2%s;\n', wdaChar, wdaChar, wdaChar );	% struct "a"
	fprintf( fid, 'o2%s = v2%s;\n', wdaChar, wdaChar );
	fprintf( fid, 'i2%s = To2%s;\n', wdaChar, wdaChar );
	fprintf( fid, 'v3%s = v1%s - v2%s;\n', wdaChar, wdaChar, wdaChar );	% struct "a"
	fprintf( fid, 'o1%s = v3%s;\n', wdaChar, wdaChar );
	fprintf( fid, 'i1%s = To1%s;\n', lowWdaChar, wdaChar );
	B1Str = sprintf( 'i1%s', lowWdaChar );

%==========================================================================================
%     IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT 
%   see comment above     see comment above     see comment above     see comment above
%==========================================================================================

%================

% input 3-port serial in bottom row, reflection free, NO inversion between B2 and A2,
% but both A2 and B2 are inverted	
function B3Str = lf_s1m_pip_pii(fid,wdaChar,A1Str,A2Str,A3Str)
	fprintf( fid, '%% bottom row 3p adaptor, type s1m_pip_pii\n' );
	fprintf( fid, 'v1%s = %s - m1%s;\n', wdaChar, A1Str, wdaChar );
	fprintf( fid, 'v2%s = %s - %s;\n', wdaChar, A1Str, A2Str );
	fprintf( fid, 'v3%s = v1%s + %s;\n', wdaChar, wdaChar, A3Str );
	fprintf( fid, 'v4%s = v2%s + %s;\n', wdaChar, wdaChar, A3Str ); 
	fprintf( fid, 'm1%s = a1%s * v4%s;\n', wdaChar, wdaChar, wdaChar ); 
	B3Str = sprintf( 'v2%s', wdaChar );  	% -B3  

% input 3-port serial in bottom row, reflection free, inversion between B2 and A2	
% to handle a -T in the top row: B2 is inverted, so A2 is treated normally	
function B3Str = lf_s1m_ppp_pii(fid,wdaChar,A1Str,A2Str,A3Str)
	fprintf( fid, '%% bottom row 3p adaptor, type s1m_ppp_pii\n' );
	fprintf( fid, 'v1%s = %s - m1%s;\n', wdaChar, A1Str, wdaChar );
	fprintf( fid, 'v2%s = %s + %s;\n', wdaChar, A1Str, A2Str );
	fprintf( fid, 'v3%s = v1%s + %s;\n', wdaChar, wdaChar, A3Str );
	fprintf( fid, 'v4%s = v2%s + %s;\n', wdaChar, wdaChar, A3Str ); 
	fprintf( fid, 'm1%s = a1%s * v4%s;\n', wdaChar, wdaChar, wdaChar ); 
	B3Str = sprintf( 'v2%s', wdaChar );  	% -B3  

% input 3-port serial in bottom row, reflection free, NO inversion between B2 and A2,
% but both A2 and B2 are inverted
% Occurs as the first one of 2 sequential s1m's	
function B3Str = lf_s1m_pip_pip(fid,wdaChar,A1Str,A2Str,A3Str)
	fprintf( fid, '%% bottom row 3p adaptor, 1st of 2 s1m''s, type s1m_pip_pip\n' );
	fprintf( fid, 'v1%s = %s - m1%s;\n', wdaChar, A1Str, wdaChar );
	fprintf( fid, 'v2%s = %s - %s;\n', wdaChar, A2Str, A1Str );				% -v2
	fprintf( fid, 'v3%s = v1%s + %s;\n', wdaChar, wdaChar, A3Str );
	fprintf( fid, 'v4%s = %s - v2%s;\n', wdaChar, A3Str, wdaChar ); 
	fprintf( fid, 'm1%s = a1%s * v4%s;\n', wdaChar, wdaChar, wdaChar ); 
	B3Str = sprintf( '-v2%s', wdaChar );  	% B3  


% input 3-port parallel in bottom row, reflection free, NO inversion between B2 and A2
% This type used for the input port 	
function B3Str = lf_p1m_ppp_ipp(fid,wdaChar,A1Str,A2Str,A3Str)
	fprintf( fid, '%% bottom row 3p adaptor, type p1m_ppp_ipp\n' );
	fprintf( fid, 'v1%s = %s - %s;\n', wdaChar, A1Str, A2Str );				% -v1
	fprintf( fid, 'v2%s = v1%s - v4%s;\n', wdaChar, wdaChar, wdaChar );		% -v2
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar );		% -m1 
	fprintf( fid, 'v3%s = %s + m1%s;\n', wdaChar, A2Str, wdaChar );
	fprintf( fid, 'v4%s = %s + m1%s;\n', wdaChar, A3Str, wdaChar ); 
	B3Str = sprintf( 'v3%s', wdaChar );  

%{ 
% THIS ONE IS COMPLETELY VALID: use this one or "lf_p1m_ppp_iip"
% are there any reasons to use one or the other???
% input 3-port parallel in bottom row, reflection free, inversion between B2 and A2
% to handle a -T in the top row: A2 is inverted
% This type used for the input port 	
function B3Str = lf_p1m_pip_ipp(fid,wdaChar,A1Str,A2Str,A3Str)
	fprintf( fid, '%% bottom row 3p adaptor, type p1m_pip_ipp\n' );
	fprintf( fid, 'v1%s = %s + %s;\n', wdaChar, A1Str, A2Str );				% -v1
	fprintf( fid, 'v2%s = v1%s - v4%s;\n', wdaChar, wdaChar, wdaChar );		% -v2
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar );		% -m1
	fprintf( fid, 'v3%s = m1%s - %s;\n', wdaChar, wdaChar, A2Str );
	fprintf( fid, 'v4%s = %s + m1%s;\n', wdaChar, A3Str, wdaChar ); 
	B3Str = sprintf( 'v3%s', wdaChar );  
%}

% input 3-port parallel in bottom row, reflection free, inversion between B2 and A2
% to handle a -T in the top row: B2 is inverted
% This type used for the input port 	
function B3Str = lf_p1m_ppp_iip(fid,wdaChar,A1Str,A2Str,A3Str)
	fprintf( fid, '%% bottom row 3p adaptor, type p1m_ppp_iip\n' );
	fprintf( fid, 'v1%s = %s - %s;\n', wdaChar, A2Str, A1Str );				% v1
	fprintf( fid, 'v2%s = v4%s - v1%s;\n', wdaChar, wdaChar, wdaChar );		% -v2
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar );		% -m1
	fprintf( fid, 'v3%s = %s - m1%s;\n', wdaChar, A2Str, wdaChar );
	fprintf( fid, 'v4%s = m1%s - %s;\n', wdaChar, wdaChar, A3Str ); 
	B3Str = sprintf( 'v3%s', wdaChar );  

% input 3-port serial in bottom row, reflection free, NO inversion between B2 and A2	
function B3Str = lf_p1m_ipp_ppp(fid,wdaChar,A1Str,A2Str,A3Str)
	fprintf( fid, '%% bottom row 3p adaptor, type p1m_ipp_ppp\n' );
	fprintf( fid, 'v1%s = %s + %s;\n', wdaChar, A1Str, A2Str );
	fprintf( fid, 'v2%s = v1%s + v4%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'v3%s = %s - m1%s;\n', wdaChar, A2Str, wdaChar );
	fprintf( fid, 'v4%s = %s - m1%s;\n', wdaChar, A3Str, wdaChar ); 
	B3Str = sprintf( 'v3%s', wdaChar );  

% input 3-port serial in bottom row, reflection free, inversion between B2 and A2	
% to handle a -T in the top row: B2 is inverted
function B3Str = lf_p1m_ipp_pip(fid,wdaChar,A1Str,A2Str,A3Str)
	fprintf( fid, '%% bottom row 3p adaptor, type p1m_ipp_pip\n' );
	fprintf( fid, 'v1%s = %s + %s;\n', wdaChar, A1Str, A2Str );
	fprintf( fid, 'v2%s = v1%s - v4%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'v3%s = %s - m1%s;\n', wdaChar, A2Str, wdaChar );
	fprintf( fid, 'v4%s = m1%s - %s;\n', wdaChar, wdaChar, A3Str ); 
	B3Str = sprintf( 'v3%s', wdaChar );  

% input 3-port parallel in bottom row, reflection free, NO inversion between B2 and A2
% situated following another parallel 3-port (in top row p or P)
function B3Str = lf_p1m_ppp_ppp(fid,wdaChar,A1Str,A2Str,A3Str)
	fprintf( fid, '%% bottom row 3p adaptor, type p1m_ppp_ppp\n' );
	fprintf( fid, 'v1%s = %s - %s;\n', wdaChar, A2Str, A1Str );
	fprintf( fid, 'v2%s = v1%s + v4%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'v3%s = %s - m1%s;\n', wdaChar, A2Str, wdaChar );
	fprintf( fid, 'v4%s = %s - m1%s;\n', wdaChar, A3Str, wdaChar ); 
	B3Str = sprintf( 'v3%s', wdaChar );  


%======= symmetrical structure, middle adaptor
% middle (if symmetrical) 3-port serial adaptor in bottom row, NO inversion between B2 and A2	
function lf_S2m_pip_pip(fid,wdaChar,A1Str,A2Str,A3Str)
	fprintf( fid, '%% middle bottom row 3p adaptor, type S2m_pip_pip\n' );
	fprintf( fid, 'v1%s = %s - m1%s;\n', wdaChar, A1Str, wdaChar );
	fprintf( fid, 'v2%s = %s - %s;\n', wdaChar, A1Str, A2Str );
	fprintf( fid, 'v3%s = v2%s + %s;\n', wdaChar, wdaChar, A3Str );
	fprintf( fid, 'v4%s = v1%s + v3%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v5%s = v4%s + v6%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'v6%s = %s - m3%s;\n', wdaChar, A3Str, wdaChar ); 
	fprintf( fid, 'm1%s = a1%s * v3%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'm3%s = a3%s * v3%s;\n', wdaChar, wdaChar, wdaChar ); 

% middle (if symmetrical) 3-port serial adaptorin bottom row, inversion between B2 and A2	
% to handle a -T in the top row: A2 is inverted
function lf_S2m_ppp_pip(fid,wdaChar,A1Str,A2Str,A3Str)
	fprintf( fid, '%% middle bottom row 3p adaptor, type S2m_ppp_pip\n' );
	fprintf( fid, 'v1%s = %s - m1%s;\n', wdaChar, A1Str, wdaChar );
	fprintf( fid, 'v2%s = %s + %s;\n', wdaChar, A2Str, A1Str );
	fprintf( fid, 'v3%s = v2%s + %s;\n', wdaChar, wdaChar, A3Str );
	fprintf( fid, 'v4%s = v1%s + v3%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v5%s = v4%s + v6%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'v6%s = %s - m3%s;\n', wdaChar, A3Str, wdaChar ); 
	fprintf( fid, 'm1%s = a1%s * v3%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'm3%s = a3%s * v3%s;\n', wdaChar, wdaChar, wdaChar ); 


% middle (if symmetrical) 3-port parallel in bottom row, NO inversion between B2 and A2	
function lf_P2m_ipi_ppp(fid,wdaChar,A1Str,A2Str,A3Str)
	fprintf( fid, '%% middle bottom row 3p adaptor, type P2m_ipi_ppp\n' );
	fprintf( fid, 'v1%s = %s + %s;\n', wdaChar, A1Str, A2Str );
	fprintf( fid, 'v2%s = v1%s + v4%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v3%s = %s - m1%s;\n', wdaChar, A2Str, wdaChar );
	fprintf( fid, 'v4%s = v3%s - m3%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'v5%s = %s + %s;\n', wdaChar, A2Str, A3Str );
	fprintf( fid, 'v6%s = v4%s + v5%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'm3%s = a3%s * v5%s;\n', wdaChar, wdaChar, wdaChar ); 
	
% middle (if symmetrical) 3-port parallel in bottom row, inversion between B2 and A2	
% to handle a -T in the top row: B2 is inverted
function lf_P2m_ipi_pip(fid,wdaChar,A1Str,A2Str,A3Str)
	fprintf( fid, '%% middle bottom row 3p adaptor, type P2m_ipi_pip\n' );
	fprintf( fid, 'v1%s = %s + %s;\n', wdaChar, A1Str, A2Str );
	fprintf( fid, 'v2%s = v1%s - v4%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v3%s = %s - m1%s;\n', wdaChar, A2Str, wdaChar );
	fprintf( fid, 'v4%s = m3%s - v3%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'v5%s = %s + %s;\n', wdaChar, A2Str, A3Str );
	fprintf( fid, 'v6%s = v5%s - v4%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'm3%s = a3%s * v5%s;\n', wdaChar, wdaChar, wdaChar ); 


%======= symmetrical structure, final adaptor --> forward output
% rightmost 3-port serial in bottom row in symmetrical setup, NO inversion between B2 and A2	
% A1 = 0, POSITIVE B1 (m3 = +1.0)
function [B1Str,B3Str] = lf_s1m_0pp_ppi(fid,wdaChar,a00Str,A2Str,A3Str)
	fprintf( fid, '%% middle bottom row 3p adaptor, type s1m_0pp_ppi\n' );
	fprintf( fid, 'v4%s = %s + %s;\n', wdaChar, A2Str, A3Str );
	fprintf( fid, 'm1%s = a1%s * v4%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'v3%s = m1%s - %s;\n', wdaChar, wdaChar, A3Str );
	fprintf( fid, 'v5%s = %s - m1%s;\n', wdaChar, a00Str, wdaChar );
	B1Str = sprintf( 'v5%s', wdaChar );		% +B1  
	B3Str = sprintf( '%s', A2Str );			% -B3   

% rightmost 3-port serial in bottom row in symmetrical setup, inversion between B2 and A2	
% to handle a -T in the top row: B2 is inverted, A1 = 0, POSITIVE B1 (m3 = +1.0)
function [B1Str,B3Str] = lf_s1m_0pp_pii(fid,wdaChar,a00Str,A2Str,A3Str)
	fprintf( fid, '%% middle bottom row 3p adaptor, type s1m_0pp_pii\n' );
	fprintf( fid, 'v4%s = %s + %s;\n', wdaChar, A2Str, A3Str );
	fprintf( fid, 'm1%s = a1%s * v4%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'v3%s = %s - m1%s;\n', wdaChar, A3Str, wdaChar );
	fprintf( fid, 'v5%s = %s - m1%s;\n', wdaChar, a00Str, wdaChar );
	B1Str = sprintf( 'v5%s', wdaChar );		% +B1  
	B3Str = sprintf( '%s', A2Str );			% -B3   

% rightmost 3-port serial in bottom row in symmetrical setup, NO inversion between B2 and A2
% A1 = 0, inverted B1 (m3 = -1.0)	
function [B1Str,B3Str] = lf_s1m_0pp_ipi(fid,wdaChar,A2Str,A3Str)
	fprintf( fid, '%% last bottom row 3p adaptor with A1=0, type s1m_0pp_ipi\n' );
	fprintf( fid, 'v4%s = %s + %s;\n', wdaChar, A2Str, A3Str );
	fprintf( fid, 'm1%s = a1%s * v4%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'v3%s = m1%s - %s;\n', wdaChar, wdaChar, A3Str );
	B1Str = sprintf( 'm1%s', wdaChar );		% -B1  
	B3Str = sprintf( '%s', A2Str );			% -B3   

% rightmost 3-port serial in bottom row in symmetrical setup, inversion between B2 and A2
% to handle a -T in the top row: B2 is inverted, A1 = 0, inverted B1 (m3 = -1.0)	
function [B1Str,B3Str] = lf_s1m_0pp_iii(fid,wdaChar,A2Str,A3Str)
	fprintf( fid, '%% last bottom row 3p adaptor with A1=0, type s1m_0pp_iii\n' );
	fprintf( fid, 'v4%s = %s + %s;\n', wdaChar, A2Str, A3Str );
	fprintf( fid, 'm1%s = a1%s * v4%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'v3%s = %s - m1%s;\n', wdaChar, A3Str, wdaChar );
	B1Str = sprintf( 'm1%s', wdaChar );		% -B1  
	B3Str = sprintf( '%s', A2Str );			% -B3   


% rightmost 3-port parallel in bottom row in symmetrical setup, NO inversion between B2 and A2
% A1 = 0, POSITIVE B1 (m3 = +1.0)	
function [B1Str,B3Str] = lf_p1m_0pp_ppp(fid,wdaChar,A2Str,A3Str)
	fprintf( fid, '%% last bottom row 3p adaptor with A1=0, type p1m_0pp_ppp\n' );
	fprintf( fid, 'm1%s = a1%s * %s;\n', wdaChar, wdaChar, A2Str ); 
	fprintf( fid, 'v3%s = %s - m1%s;\n', wdaChar, A2Str, wdaChar );
	fprintf( fid, 'v4%s = %s - m1%s;\n', wdaChar, A3Str, wdaChar );
	fprintf( fid, 'v2%s = %s + v4%s;\n', wdaChar, A2Str, wdaChar );
	B1Str = sprintf( 'v2%s', wdaChar );		% B1  
	B3Str = sprintf( 'v3%s', wdaChar );		% B3   

% rightmost 3-port parallel in bottom row in symmetrical setup, inversion between B2 and A2
% to handle a -T in the top row: B2 is inverted, A1 = 0, POSITIVE B1 (m3 = +1.0)
function [B1Str,B3Str] = lf_p1m_0pp_pip(fid,wdaChar,A2Str,A3Str)
	fprintf( fid, '%% last bottom row 3p adaptor with A1=0, type p1m_0pp_pip\n' );
	fprintf( fid, 'm1%s = a1%s * %s;\n', wdaChar, wdaChar, A2Str ); 
	fprintf( fid, 'v3%s = %s - m1%s;\n', wdaChar, A2Str, wdaChar );
	fprintf( fid, 'v4%s = m1%s - %s;\n', wdaChar, wdaChar, A3Str );
	fprintf( fid, 'v2%s = %s - v4%s;\n', wdaChar, A2Str, wdaChar );
	B1Str = sprintf( 'v2%s', wdaChar );		% B1  
	B3Str = sprintf( 'v3%s', wdaChar );		% B3   

% rightmost 3-port parallel in bottom row in symmetrical setup, NO inversion between B2 and A2	
% A1 = 0, inverted B1 (m3 = -1.0)
function [B1Str,B3Str] = lf_p1m_0pp_ipp(fid,wdaChar,a00Str,A2Str,A3Str)
	fprintf( fid, '%% last bottom row 3p adaptor with A1=0, type p1m_ipp_ppp\n' );
	fprintf( fid, 'm1%s = a1%s * %s;\n', wdaChar, wdaChar, A2Str ); 
	fprintf( fid, 'v3%s = %s - m1%s;\n', wdaChar, A2Str, wdaChar );
	fprintf( fid, 'v4%s = %s - m1%s;\n', wdaChar, A3Str, wdaChar );
	fprintf( fid, 'v2%s = %s + v4%s;\n', wdaChar, A2Str, wdaChar );
	fprintf( fid, 'v5%s = %s - v2%s;\n', wdaChar, a00Str, wdaChar );
	B1Str = sprintf( 'v5%s', wdaChar );		% B1  
	B3Str = sprintf( 'v3%s', wdaChar );		% B3   

% rightmost 3-port parallel in bottom row in symmetrical setup, inversion between B2 and A2	
% to handle a -T in the top row: B2 is inverted, A1 = 0, inverted B1 (m3 = -1.0)
function [B1Str,B3Str] = lf_p1m_0pp_iip(fid,wdaChar,A2Str,A3Str)
	fprintf( fid, '%% last bottom row 3p adaptor with A1=0, type p1m_0pp_iip\n' );
	fprintf( fid, 'm1%s = a1%s * %s;\n', wdaChar, wdaChar, A2Str ); 
	fprintf( fid, 'v3%s = %s - m1%s;\n', wdaChar, A2Str, wdaChar );
	fprintf( fid, 'v4%s = m1%s - %s;\n', wdaChar, wdaChar, A3Str );
	fprintf( fid, 'v2%s = v4%s - %s;\n', wdaChar, wdaChar, A2Str );
	B1Str = sprintf( 'v2%s', wdaChar );		% -B1  
	B3Str = sprintf( 'v3%s', wdaChar );		% B3   

%======= non symmetrical structure, final adaptor --> forward output
% rightmost 3-port serial in bottom row, NO inversion between B2 and A2	
% A3 = 0, B3 inverted (m3 = -1.0)
function [B3Str,a3Sign] = lf_S2m_pi0_pii(fid,wdaChar,A1Str,A2Str)
	fprintf( fid, '%% last bottom row 3p adaptor with A3=0, type S2m_pi0_pii\n' );
	fprintf( fid, 'v1%s = %s - m1%s;\n', wdaChar, A1Str, wdaChar );
	fprintf( fid, 'v2%s = %s - %s;\n', wdaChar, A1Str, A2Str );
	fprintf( fid, 'm1%s = a1%s * v2%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'm3%s = a3%s * v2%s;\n', wdaChar, wdaChar, wdaChar ); 
	a3Sign = '+';
	fprintf( fid, 'v4%s = v2%s + v1%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v5%s = v4%s - m3%s;\n', wdaChar, wdaChar, wdaChar ); 
	B3Str = sprintf( 'm3%s', wdaChar );  

% rightmost 3-port serial in bottom row, inversion between B2 and A2	
% to handle a -T in the top row: A2 is inverted, A3 = 0, B3 inverted (m3 = -1.0)
function [B3Str,a3Sign] = lf_S2m_pp0_pii(fid,wdaChar,A1Str,A2Str)
	fprintf( fid, '%% last bottom row 3p adaptor with A3=0, type S2m_pp0_pii\n' );
	fprintf( fid, 'v1%s = %s - m1%s;\n', wdaChar, A1Str, wdaChar );
	fprintf( fid, 'v2%s = %s + %s;\n', wdaChar, A1Str, A2Str );
	fprintf( fid, 'm1%s = a1%s * v2%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'm3%s = a3%s * v2%s;\n', wdaChar, wdaChar, wdaChar ); 
	a3Sign = '+';
	fprintf( fid, 'v4%s = v2%s + v1%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v5%s = v4%s - m3%s;\n', wdaChar, wdaChar, wdaChar ); 
	B3Str = sprintf( 'm3%s', wdaChar );  

% rightmost 3-port serial in bottom row, NO inversion between B2 and A2	
% A3 = 0, POSITIVE B3 (m3 = +1.0)
function [B3Str,a3Sign] = lf_S2m_pi0_pip(fid,wdaChar,A1Str,A2Str)
	fprintf( fid, '%% last bottom row 3p adaptor with A3=0, type S2m_pi0_pip\n' );
	fprintf( fid, 'v1%s = %s - m1%s;\n', wdaChar, A1Str, wdaChar );
	fprintf( fid, 'v2%s = %s - %s;\n', wdaChar, A1Str, A2Str );
	fprintf( fid, 'm1%s = a1%s * v2%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'm3%s = a3n%s * v2%s;\n', wdaChar, wdaChar, wdaChar );
	a3Sign = '-';
	if ( fid ~= 1 )
		beep;
		fprintf( 'NOTE: USE -alpha3 in output adaptor!\n' );
	end
	fprintf( fid, '%% NOTE: USE a3n = -a3!\n' );
	fprintf( fid, 'v4%s = v2%s + v1%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v5%s = v4%s + m3%s;\n', wdaChar, wdaChar, wdaChar ); 
	B3Str = sprintf( 'm3%s', wdaChar );  

% rightmost 3-port serial in bottom row, inversion between B2 and A2	
% to handle a -T in the top row: A2 is inverted, A3 = 0, POSITIVE B3 (m3 = +1.0)
function [B3Str,a3Sign] = lf_S2m_pp0_pip(fid,wdaChar,A1Str,A2Str)
	fprintf( fid, '%% last bottom row 3p adaptor with A3=0, type S2m_pp0_pip\n' );
	fprintf( fid, 'v1%s = %s - m1%s;\n', wdaChar, A1Str, wdaChar );
	fprintf( fid, 'v2%s = %s + %s;\n', wdaChar, A1Str, A2Str );
	fprintf( fid, 'm1%s = a1%s * v2%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'm3%s = a3n%s * v2%s;\n', wdaChar, wdaChar, wdaChar );
	a3Sign = '-';
	if ( fid ~= 1 )
		beep;
		fprintf( 'NOTE: USE -alpha3 in output adaptor!\n' );
	end
	fprintf( fid, '%% NOTE: USE a3n = -a3!\n' );
	fprintf( fid, 'v4%s = v2%s + v1%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v5%s = v4%s + m3%s;\n', wdaChar, wdaChar, wdaChar ); 
	B3Str = sprintf( 'm3%s', wdaChar );  


% rightmost 3-port parallel in bottom row, NO inversion between B2 and A2	
% A3 = 0, B3 inverted (m3 = -1.0)
function B3Str = lf_P2m_ii0_pii(fid,wdaChar,A1Str,A2Str)
	fprintf( fid, '%% last bottom row 3p adaptor with A3=0, type P2m_ii0_pii\n' );
	fprintf( fid, 'v1%s = %s - %s;\n', wdaChar, A1Str, A2Str );
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'm3%s = a3%s * %s;\n', wdaChar, wdaChar, A2Str ); 
	fprintf( fid, 'v3%s = m1%s + %s;\n', wdaChar, wdaChar, A2Str );
	fprintf( fid, 'v4%s = v3%s - m3%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'v2%s = v1%s - v4%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v6%s = v4%s + %s;\n', wdaChar, wdaChar, A2Str ); 
	B3Str = sprintf( 'v6%s', wdaChar ); 	% -B3

% rightmost 3-port parallel in bottom row, inversion between B2 and A2	
% to handle a -T in the top row: B2 is inverted, A3 = 0, B3 inverted (m3 = -1.0)
function B3Str = lf_P2m_ip0_pii(fid,wdaChar,A1Str,A2Str)
	fprintf( fid, '%% last bottom row 3p adaptor with A3=0, type P2m_ip0_pii\n' );
	fprintf( fid, 'v1%s = %s + %s;\n', wdaChar, A1Str, A2Str );
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'm3%s = a3%s * %s;\n', wdaChar, wdaChar, A2Str ); 
	fprintf( fid, 'v3%s = m1%s - %s;\n', wdaChar, wdaChar, A2Str );
	fprintf( fid, 'v4%s = v3%s + m3%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'v2%s = v1%s - v4%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v6%s = v4%s - %s;\n', wdaChar, wdaChar, A2Str ); 
	B3Str = sprintf( 'v6%s', wdaChar ); 	% -B3

% rightmost 3-port parallel in bottom row, NO inversion between B2 and A2	
% A3 = 0, POSITIVE B3 (m3 = +1.0)
function B3Str = lf_P2m_ip0_ppp(fid,wdaChar,A1Str,A2Str)
	fprintf( fid, '%% last bottom row 3p adaptor with A3=0, type P2m_ip0_ppp\n' );
	fprintf( fid, 'v1%s = %s + %s;\n', wdaChar, A1Str, A2Str );
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'm3%s = a3%s * %s;\n', wdaChar, wdaChar, A2Str ); 
	fprintf( fid, 'v3%s = %s - m1%s;\n', wdaChar, A2Str, wdaChar );
	fprintf( fid, 'v4%s = v3%s - m3%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'v2%s = v1%s + v4%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v6%s = v4%s + %s;\n', wdaChar, wdaChar, A2Str ); 
	B3Str = sprintf( 'v6%s', wdaChar ); 	% +B3

% rightmost 3-port parallel in bottom row, inversion between B2 and A2	
% to handle a -T in the top row: A2 is inverted, A3 = 0, POSITIVE B3 (m3 = +1.0)
function B3Str = lf_P2m_ii0_ppp(fid,wdaChar,A1Str,A2Str)
	fprintf( fid, '%% last bottom row 3p adaptor with A3=0, type P2m_ii0_ppp\n' );
	fprintf( fid, 'v1%s = %s - %s;\n', wdaChar, A1Str, A2Str );
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'm3%s = a3%s * %s;\n', wdaChar, wdaChar, A2Str ); 
	fprintf( fid, 'v3%s = %s + m1%s;\n', wdaChar, A2Str, wdaChar );
	fprintf( fid, 'v4%s = m3%s - v3%s;\n', wdaChar, wdaChar, wdaChar ); 
	fprintf( fid, 'v2%s = v1%s + v4%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v6%s = v4%s - %s;\n', wdaChar, wdaChar, A2Str ); 
	B3Str = sprintf( 'v6%s', wdaChar ); 	% +B3