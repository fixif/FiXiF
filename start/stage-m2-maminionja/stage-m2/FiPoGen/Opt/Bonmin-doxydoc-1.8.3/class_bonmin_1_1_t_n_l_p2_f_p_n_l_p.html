<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Bonmin: Bonmin::TNLP2FPNLP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_bonmin.html">Bonmin</a>::<a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html">TNLP2FPNLP</a>
  </div>
</div>
<div class="contents">
<h1>Bonmin::TNLP2FPNLP Class Reference</h1><!-- doxytag: class="Bonmin::TNLP2FPNLP" -->
<p>This is an adapter class to convert an NLP to a Feasibility Pump NLP by changing the objective function to the (2-norm) distance to a point.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>&gt;</code></p>

<p><a href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#aae7353c4ef96dcbc757b2c67d7a55c12">use</a> (Ipopt::SmartPtr&lt; TNLP &gt; tnlp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a025422fa4bb333c9f523e8052d5e1c0b">get_variables_linearity</a> (Ipopt::Index n, LinearityType *var_types)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a3599722d9622ccb5215b6f1b7fd925bc">get_constraints_linearity</a> (Ipopt::Index m, LinearityType *const_types)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">overload this method to return the constraint linearity.  <a href="#a3599722d9622ccb5215b6f1b7fd925bc"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors/Destructors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb6c2fc8a5f27b43dd066f92145c0ca0c"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a735de294306388c8f895bd023a1501ec">TNLP2FPNLP</a> (const Ipopt::SmartPtr&lt; Ipopt::TNLP &gt; tnlp, double objectiveScalingFactor=100)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build using tnlp as source problem.  <a href="#a735de294306388c8f895bd023a1501ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#ac553460f51eac360905ba9d8d0e3d70a">TNLP2FPNLP</a> (const Ipopt::SmartPtr&lt; TNLP &gt; tnlp, const Ipopt::SmartPtr&lt; <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html">TNLP2FPNLP</a> &gt; other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build using tnlp as source problem and using other for all other parameters.  <a href="#ac553460f51eac360905ba9d8d0e3d70a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#ae4434f17214239c9c1e4aa4a703a83a2">~TNLP2FPNLP</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default destructor.  <a href="#ae4434f17214239c9c1e4aa4a703a83a2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods to select the objective function and extra constraints</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp6987cf6f40a9d16ce7c4e932cb67cda9"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a7fc267c16fa27f35678603494f23015d">set_use_feasibility_pump_objective</a> (bool use_feasibility_pump_objective)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag to indicate that we want to use the feasibility pump objective.  <a href="#a7fc267c16fa27f35678603494f23015d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a95267431a4ba0a8a02549ea3081c8717">set_use_cutoff_constraint</a> (bool use_cutoff_constraint)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag to indicate that we want to use a cutoff constraint This constraint has the form f(x) &lt;= (1-epsilon) f(x').  <a href="#a95267431a4ba0a8a02549ea3081c8717"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a318f9059395fccef615e43bfd40117fa">set_use_local_branching_constraint</a> (bool use_local_branching_constraint)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag to indicate that we want to use a local branching constraint.  <a href="#a318f9059395fccef615e43bfd40117fa"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods to provide the rhs of the extra constraints</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp3c438223be1c4cd16c50b016af902d51"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a184da22fb15cd55d4a0f27dd2a125527">set_cutoff</a> (Ipopt::Number cutoff)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the cutoff value to use in the cutoff constraint.  <a href="#a184da22fb15cd55d4a0f27dd2a125527"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a99d6ef067a7b664444e33ed3ac06191f">set_rhs_local_branching_constraint</a> (double rhs_local_branching_constraint)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the rhs of the local branching constraint.  <a href="#a99d6ef067a7b664444e33ed3ac06191f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods to change the objective function</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp7f65cf423cc00a645c5d13996276757d"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#af283a16c6d9be9780887840142a5fe65">set_dist_to_point_obj</a> (size_t n, const Ipopt::Number *vals, const Ipopt::Index *inds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the point to which distance is minimized.  <a href="#af283a16c6d9be9780887840142a5fe65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a9c7d8d5ae53f891a5431dd0e441be707">setSigma</a> (double sigma)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the value for sigma.  <a href="#a9c7d8d5ae53f891a5431dd0e441be707"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a5b0726560364911640137d709a68fa76">setLambda</a> (double lambda)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the value for lambda.  <a href="#a5b0726560364911640137d709a68fa76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a539a335e189c4535d7188191a518d493">setNorm</a> (int norm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the value for simgma.  <a href="#a539a335e189c4535d7188191a518d493"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">methods to gather information about the NLP</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp0ee7169a44abbc68ff71e45ba9338754"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#afb8fb4392fff29d15b6b76e6af7c9a49">get_nlp_info</a> (Ipopt::Index &amp;n, Ipopt::Index &amp;m, Ipopt::Index &amp;nnz_jac_g, Ipopt::Index &amp;nnz_h_lag, Ipopt::TNLP::IndexStyleEnum &amp;index_style)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get info from nlp_ and add hessian information  <a href="#afb8fb4392fff29d15b6b76e6af7c9a49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#af33b1923c418f7615f1d9598ee5dac52">get_bounds_info</a> (Ipopt::Index n, Ipopt::Number *x_l, Ipopt::Number *x_u, Ipopt::Index m, Ipopt::Number *g_l, Ipopt::Number *g_u)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This call is just passed onto tnlp_.  <a href="#af33b1923c418f7615f1d9598ee5dac52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a1ff320bb6a451e95c20723ebcd36f15f">get_starting_point</a> (Ipopt::Index n, bool init_x, Ipopt::Number *x, bool init_z, Ipopt::Number *z_L, Ipopt::Number *z_U, Ipopt::Index m, bool init_lambda, Ipopt::Number *lambda)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Passed onto tnlp_.  <a href="#a1ff320bb6a451e95c20723ebcd36f15f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a7bf491deb52fa651f010c879abd6892e">eval_f</a> (Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Number &amp;obj_value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">overloaded to return the value of the objective function  <a href="#a7bf491deb52fa651f010c879abd6892e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#ab60cf93de95366a000f767fa87d26008">eval_grad_f</a> (Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Number *grad_f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">overload this method to return the <a class="el" href="class_bonmin_1_1vector.html" title="A small wrap around std::vector to give easy access to array for interfacing with...">vector</a> of the gradient of the objective w.r.t.  <a href="#ab60cf93de95366a000f767fa87d26008"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#af25d1719c540f96c1a0a099714e8ec01">eval_g</a> (Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Index m, Ipopt::Number *g)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">overload to return the values of the left-hand side of the constraints  <a href="#af25d1719c540f96c1a0a099714e8ec01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a8d8ed1294bbd77aa04a4baa480fc5417">eval_jac_g</a> (Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Index m, Ipopt::Index nele_jac, Ipopt::Index *iRow, Ipopt::Index *jCol, Ipopt::Number *values)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">overload to return the jacobian of g  <a href="#a8d8ed1294bbd77aa04a4baa480fc5417"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a9835f707ae61389e7917beb13ea3e6df">eval_h</a> (Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Number obj_factor, Ipopt::Index m, const Ipopt::Number *lambda, bool new_lambda, Ipopt::Index nele_hess, Ipopt::Index *iRow, Ipopt::Index *jCol, Ipopt::Number *values)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate the modified Hessian of the Lagrangian.  <a href="#a9835f707ae61389e7917beb13ea3e6df"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Solution Methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb01a6e36bf785e182005b266cd54ad55"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a73dcc9c3f41ac5430a951a1268525d40">finalize_solution</a> (Ipopt::SolverReturn status, Ipopt::Index n, const Ipopt::Number *x, const Ipopt::Number *z_L, const Ipopt::Number *z_U, Ipopt::Index m, const Ipopt::Number *g, const Ipopt::Number *lambda, Ipopt::Number obj_value, const Ipopt::IpoptData *ip_data, Ipopt::IpoptCalculatedQuantities *ip_cq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is called when the algorithm is complete so the TNLP can store/write the solution.  <a href="#a73dcc9c3f41ac5430a951a1268525d40"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Scaling of the objective function</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpf67f7e870bd923d61307c7c2f3118726"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a6fa3ba0bc31238e52a25fc00abc5c346">setObjectiveScaling</a> (double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#ade7cbaf8ead59ce51efb74107bccedf1">getObjectiveScaling</a> () const </td></tr>
<tr><td colspan="2"><h2>Private Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Internal methods to help compute the distance, its gradient and hessian</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpc28977e5170eaa20d0b88f4c0019ec5c"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a95c9cf53ea8a3d5ba3a82b70d8d85b92">dist_to_point</a> (const Ipopt::Number *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the norm-2 distance to the current point to which distance is minimized.  <a href="#a95c9cf53ea8a3d5ba3a82b70d8d85b92"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Default Compiler Generated Methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpf2292ef68c5cb71335fe9cf428fcaeaf"></a>(Hidden to avoid implicit creation/calling).</p>
<p>These methods are not implemented and we do not want the compiler to implement them for us, so we declare them private and do not define them. This ensures that they will not be implicitly created/called. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#aadd290b723a4f2437a2bdbe91f5d05b3">TNLP2FPNLP</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default Constructor.  <a href="#aadd290b723a4f2437a2bdbe91f5d05b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#afac3d86557850d8e239738d7efa6547d">TNLP2FPNLP</a> (const <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html">TNLP2FPNLP</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy Constructor.  <a href="#afac3d86557850d8e239738d7efa6547d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a8c51fff3e60092adfbac69ce74e48a70">operator=</a> (const <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html">TNLP2FPNLP</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded Equals Operator.  <a href="#a8c51fff3e60092adfbac69ce74e48a70"></a><br/></td></tr>
<tr><td colspan="2"><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ipopt::SmartPtr&lt; TNLP &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a7d45fac8d02fcd04053f235c7bac11d4">tnlp_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pointer to the tminlp that is being adapted  <a href="#a7d45fac8d02fcd04053f235c7bac11d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a08e0a3648b8edebe0f8c62f684525eb0">objectiveScalingFactor_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scaling factor for the objective.  <a href="#a08e0a3648b8edebe0f8c62f684525eb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ipopt::TNLP::IndexStyleEnum&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#af6acd3ab5b84aa069d7ea9997875c5d2">index_style_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ipopt::Index style (C++ or Fortran).  <a href="#af6acd3ab5b84aa069d7ea9997875c5d2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Data for storing the point the distance to which is minimized</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp494ed576f6ad76d7d4a7f7063ee91351"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bonmin_1_1vector.html">vector</a>&lt; Ipopt::Index &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a804ce4a0b995422aaddc25a1211bc7f0">inds_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indices of the variables for which distance is minimized (i.e. indices of integer variables in a feasibility pump setting).  <a href="#a804ce4a0b995422aaddc25a1211bc7f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_bonmin_1_1vector.html">vector</a>&lt; Ipopt::Number &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#ad1a352e0b8d67f9f9889b1006f024ffb">vals_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Values of the point to which we separate (if x is the point vals_[i] should be x[inds_[i]] ).  <a href="#ad1a352e0b8d67f9f9889b1006f024ffb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#af3688ac33dfd5140b7cc26b7651fce53">lambda_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">value for the convex combination to take between original objective and distance function.  <a href="#af3688ac33dfd5140b7cc26b7651fce53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#af254654bf51c3381f279f62f76f194e0">sigma_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scaling for the original objective.  <a href="#af254654bf51c3381f279f62f76f194e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a1cd1340aa74a65cc91b2f72c3859453c">norm_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Norm to use (L_1 or L_2).  <a href="#a1cd1340aa74a65cc91b2f72c3859453c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Flags to select the objective function and extra constraints</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp13d9141a07c3e8083c9fe14968ed64d9"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#ae49efe406f2eaa67e3a2f843a0622e2b">use_feasibility_pump_objective_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag to indicate that we want to use the feasibility pump objective.  <a href="#ae49efe406f2eaa67e3a2f843a0622e2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a1c6282c8ca32187351a854c672b21e02">use_cutoff_constraint_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag to indicate that we want to use a cutoff constraint This constraint has the form f(x) &lt;= (1-epsilon) f(x').  <a href="#a1c6282c8ca32187351a854c672b21e02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#afdf00e2cf28f146cb5fb96b5589bdd1d">use_local_branching_constraint_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag to indicate that we want to use a local branching constraint.  <a href="#afdf00e2cf28f146cb5fb96b5589bdd1d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Data for storing the rhs of the extra constraints</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp4b5237587dc86d6f42984c204b427359"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a45897094d50ac854b3c74869530e0f6c">cutoff_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value of best solution known.  <a href="#a45897094d50ac854b3c74869530e0f6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a905a1474f59ec545eeab4cbcf223d79a">rhs_local_branching_constraint_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RHS of local branching constraint.  <a href="#a905a1474f59ec545eeab4cbcf223d79a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This is an adapter class to convert an NLP to a Feasibility Pump NLP by changing the objective function to the (2-norm) distance to a point. </p>
<p>The extra function is set_dist_to_point_obj(size_t n, const double *, const int *) </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00022">22</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a735de294306388c8f895bd023a1501ec"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::TNLP2FPNLP" ref="a735de294306388c8f895bd023a1501ec" args="(const Ipopt::SmartPtr&lt; Ipopt::TNLP &gt; tnlp, double objectiveScalingFactor=100)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bonmin::TNLP2FPNLP::TNLP2FPNLP </td>
          <td>(</td>
          <td class="paramtype">const Ipopt::SmartPtr&lt; Ipopt::TNLP &gt;&nbsp;</td>
          <td class="paramname"> <em>tnlp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>objectiveScalingFactor</em> = <code>100</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build using tnlp as source problem. </p>

</div>
</div>
<a class="anchor" id="ac553460f51eac360905ba9d8d0e3d70a"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::TNLP2FPNLP" ref="ac553460f51eac360905ba9d8d0e3d70a" args="(const Ipopt::SmartPtr&lt; TNLP &gt; tnlp, const Ipopt::SmartPtr&lt; TNLP2FPNLP &gt; other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bonmin::TNLP2FPNLP::TNLP2FPNLP </td>
          <td>(</td>
          <td class="paramtype">const Ipopt::SmartPtr&lt; TNLP &gt;&nbsp;</td>
          <td class="paramname"> <em>tnlp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::SmartPtr&lt; <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html">TNLP2FPNLP</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build using tnlp as source problem and using other for all other parameters. </p>

</div>
</div>
<a class="anchor" id="ae4434f17214239c9c1e4aa4a703a83a2"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::~TNLP2FPNLP" ref="ae4434f17214239c9c1e4aa4a703a83a2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Bonmin::TNLP2FPNLP::~TNLP2FPNLP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<a class="anchor" id="aadd290b723a4f2437a2bdbe91f5d05b3"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::TNLP2FPNLP" ref="aadd290b723a4f2437a2bdbe91f5d05b3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bonmin::TNLP2FPNLP::TNLP2FPNLP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default Constructor. </p>

</div>
</div>
<a class="anchor" id="afac3d86557850d8e239738d7efa6547d"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::TNLP2FPNLP" ref="afac3d86557850d8e239738d7efa6547d" args="(const TNLP2FPNLP &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bonmin::TNLP2FPNLP::TNLP2FPNLP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html">TNLP2FPNLP</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy Constructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aae7353c4ef96dcbc757b2c67d7a55c12"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::use" ref="aae7353c4ef96dcbc757b2c67d7a55c12" args="(Ipopt::SmartPtr&lt; TNLP &gt; tnlp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bonmin::TNLP2FPNLP::use </td>
          <td>(</td>
          <td class="paramtype">Ipopt::SmartPtr&lt; TNLP &gt;&nbsp;</td>
          <td class="paramname"> <em>tnlp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00036">36</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>References <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00215">tnlp_</a>.</p>

</div>
</div>
<a class="anchor" id="a7fc267c16fa27f35678603494f23015d"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::set_use_feasibility_pump_objective" ref="a7fc267c16fa27f35678603494f23015d" args="(bool use_feasibility_pump_objective)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bonmin::TNLP2FPNLP::set_use_feasibility_pump_objective </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_feasibility_pump_objective</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to indicate that we want to use the feasibility pump objective. </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00041">41</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>References <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00238">use_feasibility_pump_objective_</a>.</p>

</div>
</div>
<a class="anchor" id="a95267431a4ba0a8a02549ea3081c8717"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::set_use_cutoff_constraint" ref="a95267431a4ba0a8a02549ea3081c8717" args="(bool use_cutoff_constraint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bonmin::TNLP2FPNLP::set_use_cutoff_constraint </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_cutoff_constraint</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to indicate that we want to use a cutoff constraint This constraint has the form f(x) &lt;= (1-epsilon) f(x'). </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00046">46</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>References <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00242">use_cutoff_constraint_</a>.</p>

</div>
</div>
<a class="anchor" id="a318f9059395fccef615e43bfd40117fa"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::set_use_local_branching_constraint" ref="a318f9059395fccef615e43bfd40117fa" args="(bool use_local_branching_constraint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bonmin::TNLP2FPNLP::set_use_local_branching_constraint </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_local_branching_constraint</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to indicate that we want to use a local branching constraint. </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00050">50</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>References <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00245">use_local_branching_constraint_</a>.</p>

</div>
</div>
<a class="anchor" id="a184da22fb15cd55d4a0f27dd2a125527"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::set_cutoff" ref="a184da22fb15cd55d4a0f27dd2a125527" args="(Ipopt::Number cutoff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bonmin::TNLP2FPNLP::set_cutoff </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Number&nbsp;</td>
          <td class="paramname"> <em>cutoff</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the cutoff value to use in the cutoff constraint. </p>

</div>
</div>
<a class="anchor" id="a99d6ef067a7b664444e33ed3ac06191f"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::set_rhs_local_branching_constraint" ref="a99d6ef067a7b664444e33ed3ac06191f" args="(double rhs_local_branching_constraint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bonmin::TNLP2FPNLP::set_rhs_local_branching_constraint </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>rhs_local_branching_constraint</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the rhs of the local branching constraint. </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00060">60</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>References <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00254">rhs_local_branching_constraint_</a>.</p>

</div>
</div>
<a class="anchor" id="af283a16c6d9be9780887840142a5fe65"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::set_dist_to_point_obj" ref="af283a16c6d9be9780887840142a5fe65" args="(size_t n, const Ipopt::Number *vals, const Ipopt::Index *inds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bonmin::TNLP2FPNLP::set_dist_to_point_obj </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Index *&nbsp;</td>
          <td class="paramname"> <em>inds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the point to which distance is minimized. </p>
<p>The distance is minimize in a subspace define by a subset of coordinates </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>number of coordinates on which distance is minimized </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inds</em>&nbsp;</td><td>indices of the coordinates on which distance is minimized </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vals</em>&nbsp;</td><td>values of the point for coordinates in ind </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c7d8d5ae53f891a5431dd0e441be707"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::setSigma" ref="a9c7d8d5ae53f891a5431dd0e441be707" args="(double sigma)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bonmin::TNLP2FPNLP::setSigma </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sigma</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the value for sigma. </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00076">76</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>References <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00227">sigma_</a>.</p>

</div>
</div>
<a class="anchor" id="a5b0726560364911640137d709a68fa76"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::setLambda" ref="a5b0726560364911640137d709a68fa76" args="(double lambda)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bonmin::TNLP2FPNLP::setLambda </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>lambda</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the value for lambda. </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00080">80</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>References <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00225">lambda_</a>.</p>

</div>
</div>
<a class="anchor" id="a539a335e189c4535d7188191a518d493"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::setNorm" ref="a539a335e189c4535d7188191a518d493" args="(int norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bonmin::TNLP2FPNLP::setNorm </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>norm</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the value for simgma. </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00084">84</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>References <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00229">norm_</a>.</p>

</div>
</div>
<a class="anchor" id="afb8fb4392fff29d15b6b76e6af7c9a49"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::get_nlp_info" ref="afb8fb4392fff29d15b6b76e6af7c9a49" args="(Ipopt::Index &amp;n, Ipopt::Index &amp;m, Ipopt::Index &amp;nnz_jac_g, Ipopt::Index &amp;nnz_h_lag, Ipopt::TNLP::IndexStyleEnum &amp;index_style)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TNLP2FPNLP::get_nlp_info </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>nnz_jac_g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index &amp;&nbsp;</td>
          <td class="paramname"> <em>nnz_h_lag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::TNLP::IndexStyleEnum &amp;&nbsp;</td>
          <td class="paramname"> <em>index_style</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get info from nlp_ and add hessian information </p>

</div>
</div>
<a class="anchor" id="af33b1923c418f7615f1d9598ee5dac52"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::get_bounds_info" ref="af33b1923c418f7615f1d9598ee5dac52" args="(Ipopt::Index n, Ipopt::Number *x_l, Ipopt::Number *x_u, Ipopt::Index m, Ipopt::Number *g_l, Ipopt::Number *g_u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TNLP2FPNLP::get_bounds_info </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>x_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>x_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>g_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>g_u</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This call is just passed onto tnlp_. </p>

</div>
</div>
<a class="anchor" id="a1ff320bb6a451e95c20723ebcd36f15f"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::get_starting_point" ref="a1ff320bb6a451e95c20723ebcd36f15f" args="(Ipopt::Index n, bool init_x, Ipopt::Number *x, bool init_z, Ipopt::Number *z_L, Ipopt::Number *z_U, Ipopt::Index m, bool init_lambda, Ipopt::Number *lambda)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TNLP2FPNLP::get_starting_point </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>init_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>init_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>z_L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>z_U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>init_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>lambda</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Passed onto tnlp_. </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00102">102</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>References <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00215">tnlp_</a>, <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00242">use_cutoff_constraint_</a>, and <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00245">use_local_branching_constraint_</a>.</p>

</div>
</div>
<a class="anchor" id="a7bf491deb52fa651f010c879abd6892e"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::eval_f" ref="a7bf491deb52fa651f010c879abd6892e" args="(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Number &amp;obj_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TNLP2FPNLP::eval_f </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>new_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number &amp;&nbsp;</td>
          <td class="paramname"> <em>obj_value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overloaded to return the value of the objective function </p>

</div>
</div>
<a class="anchor" id="ab60cf93de95366a000f767fa87d26008"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::eval_grad_f" ref="ab60cf93de95366a000f767fa87d26008" args="(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Number *grad_f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TNLP2FPNLP::eval_grad_f </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>new_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>grad_f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload this method to return the <a class="el" href="class_bonmin_1_1vector.html" title="A small wrap around std::vector to give easy access to array for interfacing with...">vector</a> of the gradient of the objective w.r.t. </p>
<p>x </p>

</div>
</div>
<a class="anchor" id="af25d1719c540f96c1a0a099714e8ec01"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::eval_g" ref="af25d1719c540f96c1a0a099714e8ec01" args="(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Index m, Ipopt::Number *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TNLP2FPNLP::eval_g </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>new_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload to return the values of the left-hand side of the constraints </p>

</div>
</div>
<a class="anchor" id="a8d8ed1294bbd77aa04a4baa480fc5417"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::eval_jac_g" ref="a8d8ed1294bbd77aa04a4baa480fc5417" args="(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Index m, Ipopt::Index nele_jac, Ipopt::Index *iRow, Ipopt::Index *jCol, Ipopt::Number *values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TNLP2FPNLP::eval_jac_g </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>new_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>nele_jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index *&nbsp;</td>
          <td class="paramname"> <em>iRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index *&nbsp;</td>
          <td class="paramname"> <em>jCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>values</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload to return the jacobian of g </p>

</div>
</div>
<a class="anchor" id="a9835f707ae61389e7917beb13ea3e6df"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::eval_h" ref="a9835f707ae61389e7917beb13ea3e6df" args="(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Number obj_factor, Ipopt::Index m, const Ipopt::Number *lambda, bool new_lambda, Ipopt::Index nele_hess, Ipopt::Index *iRow, Ipopt::Index *jCol, Ipopt::Number *values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TNLP2FPNLP::eval_h </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>new_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number&nbsp;</td>
          <td class="paramname"> <em>obj_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>new_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>nele_hess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index *&nbsp;</td>
          <td class="paramname"> <em>iRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index *&nbsp;</td>
          <td class="paramname"> <em>jCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>values</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate the modified Hessian of the Lagrangian. </p>

</div>
</div>
<a class="anchor" id="a73dcc9c3f41ac5430a951a1268525d40"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::finalize_solution" ref="a73dcc9c3f41ac5430a951a1268525d40" args="(Ipopt::SolverReturn status, Ipopt::Index n, const Ipopt::Number *x, const Ipopt::Number *z_L, const Ipopt::Number *z_U, Ipopt::Index m, const Ipopt::Number *g, const Ipopt::Number *lambda, Ipopt::Number obj_value, const Ipopt::IpoptData *ip_data, Ipopt::IpoptCalculatedQuantities *ip_cq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Bonmin::TNLP2FPNLP::finalize_solution </td>
          <td>(</td>
          <td class="paramtype">Ipopt::SolverReturn&nbsp;</td>
          <td class="paramname"> <em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>z_L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>z_U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number&nbsp;</td>
          <td class="paramname"> <em>obj_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::IpoptData *&nbsp;</td>
          <td class="paramname"> <em>ip_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::IpoptCalculatedQuantities *&nbsp;</td>
          <td class="paramname"> <em>ip_cq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is called when the algorithm is complete so the TNLP can store/write the solution. </p>

</div>
</div>
<a class="anchor" id="a025422fa4bb333c9f523e8052d5e1c0b"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::get_variables_linearity" ref="a025422fa4bb333c9f523e8052d5e1c0b" args="(Ipopt::Index n, LinearityType *var_types)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TNLP2FPNLP::get_variables_linearity </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinearityType *&nbsp;</td>
          <td class="paramname"> <em>var_types</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00158">158</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>References <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00215">tnlp_</a>.</p>

</div>
</div>
<a class="anchor" id="a3599722d9622ccb5215b6f1b7fd925bc"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::get_constraints_linearity" ref="a3599722d9622ccb5215b6f1b7fd925bc" args="(Ipopt::Index m, LinearityType *const_types)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TNLP2FPNLP::get_constraints_linearity </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinearityType *&nbsp;</td>
          <td class="paramname"> <em>const_types</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload this method to return the constraint linearity. </p>
<p>array should be alocated with length at least n. (default implementation just return false and does not fill the array). </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00166">166</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>References <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00215">tnlp_</a>, <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00242">use_cutoff_constraint_</a>, and <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00245">use_local_branching_constraint_</a>.</p>

</div>
</div>
<a class="anchor" id="a6fa3ba0bc31238e52a25fc00abc5c346"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::setObjectiveScaling" ref="a6fa3ba0bc31238e52a25fc00abc5c346" args="(double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bonmin::TNLP2FPNLP::setObjectiveScaling </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00181">181</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>References <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00233">objectiveScalingFactor_</a>.</p>

</div>
</div>
<a class="anchor" id="ade7cbaf8ead59ce51efb74107bccedf1"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::getObjectiveScaling" ref="ade7cbaf8ead59ce51efb74107bccedf1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bonmin::TNLP2FPNLP::getObjectiveScaling </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00185">185</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>References <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00233">objectiveScalingFactor_</a>.</p>

</div>
</div>
<a class="anchor" id="a95c9cf53ea8a3d5ba3a82b70d8d85b92"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::dist_to_point" ref="a95c9cf53ea8a3d5ba3a82b70d8d85b92" args="(const Ipopt::Number *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Bonmin::TNLP2FPNLP::dist_to_point </td>
          <td>(</td>
          <td class="paramtype">const Ipopt::Number *&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the norm-2 distance to the current point to which distance is minimized. </p>

</div>
</div>
<a class="anchor" id="a8c51fff3e60092adfbac69ce74e48a70"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::operator=" ref="a8c51fff3e60092adfbac69ce74e48a70" args="(const TNLP2FPNLP &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bonmin::TNLP2FPNLP::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html">TNLP2FPNLP</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded Equals Operator. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a7d45fac8d02fcd04053f235c7bac11d4"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::tnlp_" ref="a7d45fac8d02fcd04053f235c7bac11d4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ipopt::SmartPtr&lt;TNLP&gt; <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a7d45fac8d02fcd04053f235c7bac11d4">Bonmin::TNLP2FPNLP::tnlp_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>pointer to the tminlp that is being adapted </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00215">215</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>Referenced by <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00166">get_constraints_linearity()</a>, <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00102">get_starting_point()</a>, <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00158">get_variables_linearity()</a>, and <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00036">use()</a>.</p>

</div>
</div>
<a class="anchor" id="a804ce4a0b995422aaddc25a1211bc7f0"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::inds_" ref="a804ce4a0b995422aaddc25a1211bc7f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bonmin_1_1vector.html">vector</a>&lt;Ipopt::Index&gt; <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a804ce4a0b995422aaddc25a1211bc7f0">Bonmin::TNLP2FPNLP::inds_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indices of the variables for which distance is minimized (i.e. indices of integer variables in a feasibility pump setting). </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00220">220</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad1a352e0b8d67f9f9889b1006f024ffb"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::vals_" ref="ad1a352e0b8d67f9f9889b1006f024ffb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_bonmin_1_1vector.html">vector</a>&lt;Ipopt::Number&gt; <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#ad1a352e0b8d67f9f9889b1006f024ffb">Bonmin::TNLP2FPNLP::vals_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Values of the point to which we separate (if x is the point vals_[i] should be x[inds_[i]] ). </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00222">222</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3688ac33dfd5140b7cc26b7651fce53"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::lambda_" ref="af3688ac33dfd5140b7cc26b7651fce53" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#af3688ac33dfd5140b7cc26b7651fce53">Bonmin::TNLP2FPNLP::lambda_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>value for the convex combination to take between original objective and distance function. </p>
<p>( take lambda_ * distance + (1-lambda) sigma f(x). </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00225">225</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>Referenced by <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00080">setLambda()</a>.</p>

</div>
</div>
<a class="anchor" id="af254654bf51c3381f279f62f76f194e0"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::sigma_" ref="af254654bf51c3381f279f62f76f194e0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#af254654bf51c3381f279f62f76f194e0">Bonmin::TNLP2FPNLP::sigma_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scaling for the original objective. </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00227">227</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>Referenced by <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00076">setSigma()</a>.</p>

</div>
</div>
<a class="anchor" id="a1cd1340aa74a65cc91b2f72c3859453c"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::norm_" ref="a1cd1340aa74a65cc91b2f72c3859453c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a1cd1340aa74a65cc91b2f72c3859453c">Bonmin::TNLP2FPNLP::norm_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Norm to use (L_1 or L_2). </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00229">229</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>Referenced by <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00084">setNorm()</a>.</p>

</div>
</div>
<a class="anchor" id="a08e0a3648b8edebe0f8c62f684525eb0"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::objectiveScalingFactor_" ref="a08e0a3648b8edebe0f8c62f684525eb0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a08e0a3648b8edebe0f8c62f684525eb0">Bonmin::TNLP2FPNLP::objectiveScalingFactor_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scaling factor for the objective. </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00233">233</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>Referenced by <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00185">getObjectiveScaling()</a>, and <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00181">setObjectiveScaling()</a>.</p>

</div>
</div>
<a class="anchor" id="ae49efe406f2eaa67e3a2f843a0622e2b"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::use_feasibility_pump_objective_" ref="ae49efe406f2eaa67e3a2f843a0622e2b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#ae49efe406f2eaa67e3a2f843a0622e2b">Bonmin::TNLP2FPNLP::use_feasibility_pump_objective_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to indicate that we want to use the feasibility pump objective. </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00238">238</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>Referenced by <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00041">set_use_feasibility_pump_objective()</a>.</p>

</div>
</div>
<a class="anchor" id="a1c6282c8ca32187351a854c672b21e02"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::use_cutoff_constraint_" ref="a1c6282c8ca32187351a854c672b21e02" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a1c6282c8ca32187351a854c672b21e02">Bonmin::TNLP2FPNLP::use_cutoff_constraint_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to indicate that we want to use a cutoff constraint This constraint has the form f(x) &lt;= (1-epsilon) f(x'). </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00242">242</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>Referenced by <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00166">get_constraints_linearity()</a>, <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00102">get_starting_point()</a>, and <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00046">set_use_cutoff_constraint()</a>.</p>

</div>
</div>
<a class="anchor" id="afdf00e2cf28f146cb5fb96b5589bdd1d"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::use_local_branching_constraint_" ref="afdf00e2cf28f146cb5fb96b5589bdd1d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#afdf00e2cf28f146cb5fb96b5589bdd1d">Bonmin::TNLP2FPNLP::use_local_branching_constraint_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to indicate that we want to use a local branching constraint. </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00245">245</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>Referenced by <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00166">get_constraints_linearity()</a>, <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00102">get_starting_point()</a>, and <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00050">set_use_local_branching_constraint()</a>.</p>

</div>
</div>
<a class="anchor" id="a45897094d50ac854b3c74869530e0f6c"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::cutoff_" ref="a45897094d50ac854b3c74869530e0f6c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a45897094d50ac854b3c74869530e0f6c">Bonmin::TNLP2FPNLP::cutoff_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Value of best solution known. </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00251">251</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a905a1474f59ec545eeab4cbcf223d79a"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::rhs_local_branching_constraint_" ref="a905a1474f59ec545eeab4cbcf223d79a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#a905a1474f59ec545eeab4cbcf223d79a">Bonmin::TNLP2FPNLP::rhs_local_branching_constraint_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RHS of local branching constraint. </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00254">254</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

<p>Referenced by <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00060">set_rhs_local_branching_constraint()</a>.</p>

</div>
</div>
<a class="anchor" id="af6acd3ab5b84aa069d7ea9997875c5d2"></a><!-- doxytag: member="Bonmin::TNLP2FPNLP::index_style_" ref="af6acd3ab5b84aa069d7ea9997875c5d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ipopt::TNLP::IndexStyleEnum <a class="el" href="class_bonmin_1_1_t_n_l_p2_f_p_n_l_p.html#af6acd3ab5b84aa069d7ea9997875c5d2">Bonmin::TNLP2FPNLP::index_style_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ipopt::Index style (C++ or Fortran). </p>

<p>Definition at line <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html#l00258">258</a> of file <a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_bon_t_n_l_p2_f_p_n_l_p_8hpp_source.html">BonTNLP2FPNLP.hpp</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 4 Jun 2015 for Bonmin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
