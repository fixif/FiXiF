function coeffs = LWDF2cir(LWDF,dlyLorR,cirFilename)
%LWDF2CIR	Writes the LWDF structure as a .cir description for scheduling
%	coeffs = LWDF2CIR(LWDF,dlyLorR,cirFilename) converts the structure in LWDF, 
%	which should contain the fields
%		LWDF.wdaCodes
%		LWDF.insRegs (optional)
%		LWDF.gamma
%	in the .cir format used by the scheduling functions and writes it to cirFilename. 
%	dlyLorR should be an 'L' (for left arm) or 'R' (for right arm) and specifies the 
%	location of the 'interconnect' delay between the 2-port adaptors of a 2nd degree 
%	section (if any). If not specified, an 'L' will be assumed. 
%	If cirFilename is not specified, output is written to the command window.
%	The optional field LWDF.insRegs specifies whether and where pipeline registers
%	should be inserted and -if present- consists of a vector of 1's and/or 0's.
%	In the cell-array coeffs, the operation names assigned in the cir file are linked 
%	to the multiplication constants (LWDF.gamma) of LWDF.
%
% 	See also WDF2CIR, HS2LWDF, SHOWLWDF.

% (c) H.J. Lincklaen Arriens, 
%     Delft University of Technology, September 2005
%									  Feb 2006, added dlyLorR possibility
 
 
if ( nargin < 3 )  
	fid = 1;
else
	fid = fopen(cirFilename,'w');
	% SHOULD BE: TEST FOR EXISTING ONE AND, IF SO, ASK PERMISSION TO OVERWRITE
	if ( fid == -1 )
		error( 'Cannot create file "%s" ...', cirFilename );
	end  
end
if ( nargin < 2 )
	dlyLorR = 'L';
else
	dlyLorR = upper(dlyLorR);
	if ~( (dlyLorR == 'L') || (dlyLorR == 'R') )
		error( 'LWDF2cir syntax error: dlyLorR should be ''L'' or ''R'' ...' );
	end
end

wdaCodes = LWDF.wdaCodes;
if isfield(LWDF,'insRegs')
	insRegsVec  = LWDF.insRegs;
	insRegsFlag = 1;
else 
	insRegsFlag = 0;
end;

% determine filter order from description in wdaCodes
codes = wdaCodes(:);
order1 = sum( (codes == 't') | (codes == 's') );
order2 = sum( (codes == 'S') | (codes == 'd') );
order4 = sum( (codes == 'D') );
filterOrder = order1 + 2*order2 + 4*order4;

lowPass = ( rem(filterOrder,2) == 1 );
% determine number of multiplications needed
gamma  = LWDF.gamma;
% to one row of only the valid multiplication values
gamma  = gamma( (abs(gamma) > 1e-12) & ~isnan(gamma) );
nGamma = length(gamma);
for i = 1:nGamma
	coeffs(i,:) = [ {'xxx'}  gamma(i) ]; 
end

if ( (wdaCodes(1,1) == 'S') || any(any( wdaCodes == 'D' )) )
	fTypeStr = 'symmetrical (around samplefrequency/4) bandpass/bandstop filter';
elseif all( wdaCodes(wdaCodes ~= 'x') == 'd' ) 
		fTypeStr = 'bandpass/bandstop filter';
	elseif ( wdaCodes(1,1) == 't' )	
			fTypeStr = 'bireciprocal lowpass/highpass filter';
		elseif ( wdaCodes(1,1) == 's' )
				fTypeStr = 'lowpass/highpass filter';
			else
				wdaCodes
				beep;
				error( 'Unknown filter type ...' );
end

fprintf( fid, '%% %s of Order %d\n', fTypeStr, filterOrder );
fprintf( fid, '%% as a Lattice Wave Digital Filter structure.\n' );
fprintf( fid, '%% Code generated by LWDF2cir.m on %s.\n\n', datestr(clock) );

if lowPass
	outpStr = [ 'hp'; 'lp' ];
else
	outpStr = [ 'bp'; 'bs' ];
end
fprintf( fid, '%% external input ''inp'', external outputs ''o_%s'' and ''o_%s''\n\n', ...
														outpStr(1,:), outpStr(2,:) );

nSlices     = size(wdaCodes,2);
filterInStr = 'inp';
wdaChar     =   'A';
coeffsIx    =     1;

% adept the filters structure when pipelining registers are to be inserted
if insRegsFlag
	for i = 1:2
		if ( wdaCodes(i,end) == 'x' )
			wdaCodes(i,:) = [ 'x'  wdaCodes(i,1:end-1) ];
		end
	end
	newCodes = char( char('x')*ones(2,2*nSlices-1) );
	newCodes(:,1:2:end) = wdaCodes;
	for i = 1:nSlices-1
		if ( insRegsVec(i) == 1 )
			newCodes(:,2*i) = [ 'r'; 'r' ];
		else
			newCodes(:,2*i) = [ '-'; '-' ];
		end
	end
	wdaCodes = newCodes;
	nSlices = 2*nSlices -1;
end

fprintf( fid, '\n%% TOP ROW ALL-PASS SECTION(S):\n' );
inpStr = filterInStr;
iRegNo = 1;
for i = 1:nSlices
	isWda = 0;
	switch wdaCodes(1,i)
		case 't'
			fprintf( fid, '%% single delay\n' );
			fprintf( fid, 'o1 = %s;\n', inpStr );
			fprintf( fid, 'i1 = To1;\n\n' );
			inpStr = 'i1';
		case 's'
			fprintf( fid, '%% single section, single delay:\n' );
			inpStr = lfSingleSection1T(fid,wdaChar,inpStr);
			isWda  = 1;
		case 'S'
			fprintf( fid, '%% single section, double delays\n' );
			inpStr = lfSingleSection2T(fid,wdaChar,inpStr);
			isWda  = 1;
		case 'd'
			fprintf( fid, '%% 2nd degree section, 2 delay elements:\n' );
			inpStr = lfDoubleSection1T(fid,dlyLorR,wdaChar,inpStr);
			isWda  = 1;
		case 'D'
			fprintf( fid, '%% double section, 2 double delay elements\n' );
			inpStr = lfDoubleSection2T(fid,dlyLorR,wdaChar,inpStr);
			isWda  = 1;
		case 'r'
			fprintf( fid, '%% inserted pipeline register:\n' );
			inpStr = lfInsertedReg(fid,'t',iRegNo,inpStr);
			iRegNo = iRegNo +1;
		case '-'
			iRegNo = iRegNo +1;
	end
	if isWda
		switch wdaCodes(1,i)
				case {'s','S'}
				coeffs(coeffsIx,1) = { sprintf( 'a1%s', wdaChar ) };
				coeffsIx = coeffsIx +1;
			case {'d','D'}
				coeffs(coeffsIx  ,1) = { sprintf( 'a1%s', wdaChar ) };
				coeffs(coeffsIx+1,1) = { sprintf( 'a2%s', wdaChar ) };
				coeffsIx = coeffsIx +2;
		end
		wdaChar = char(wdaChar +1);
	end
end
topOutStr = inpStr;

fprintf( fid, '\n%% BOTTOM ROW ALL-PASS SECTION(S):\n' );
inpStr = filterInStr;
iRegNo = 1;
nBottomRowSlices = sum( wdaCodes(2,:) ~= 'x' );
if ( nBottomRowSlices >= 1 )
	for i = 1:nSlices
		isWda = 0;
		switch wdaCodes(2,i)
		case 'S'
			fprintf( fid, '%% single section, double delays\n' );
			inpStr = lfSingleSection2T(fid,wdaChar,inpStr);
			isWda  = 1;
		case 'd'
			fprintf( fid, '%% 2nd degree section, 2 delay elements:\n' );
			inpStr = lfDoubleSection1T(fid,dlyLorR,wdaChar,inpStr);
			isWda  = 1;
		case 'D'
			fprintf( fid, '%% double section, 2 double delay elements\n' );
			inpStr = lfDoubleSection2T(fid,dlyLorR,wdaChar,inpStr);
			isWda  = 1;
		case 'r'
			fprintf( fid, '%% inserted pipeline register:\n' );
			inpStr = lfInsertedReg(fid,'b',iRegNo,inpStr);
			iRegNo = iRegNo +1;
		case '-'
			iRegNo = iRegNo +1;
		end
		if isWda
			switch wdaCodes(2,i)
				case {'S'}
					coeffs(coeffsIx,1) = { sprintf( 'a1%s', wdaChar ) };
					coeffsIx = coeffsIx +1;
				case {'d','D'}
					coeffs(coeffsIx  ,1) = { sprintf( 'a1%s', wdaChar ) };
					coeffs(coeffsIx+1,1) = { sprintf( 'a2%s', wdaChar ) };
					coeffsIx = coeffsIx +2;
			end
			wdaChar = char(wdaChar +1);
		end
	end 
else
	fprintf( '  just a straight connection ...\n' );
end
btmOutStr = inpStr;

fprintf( fid, '\n%% OUTPUT SECTION:\n' );
% bandpass output (X2) 
fprintf( fid, 'v1 = %s - %s;\n', btmOutStr, topOutStr );
fprintf( fid, 'o_%s = (v1 >> 1);   %% v1/2\n', outpStr(1,:) );
fprintf( fid, 'v2 = %s + %s;\n', btmOutStr, topOutStr );
fprintf( fid, 'o_%s = (v2 >> 1);   %% v2/2\n', outpStr(2,:) );
 
if ( fid ~= 1 )
	fprintf( fid, '\n\n%% (c) HJLA, 2005\n%% [EOF]\n' );
	fclose(fid);
end


%==========================================================================================
%=========  LOCAL FUNCTIONS  ======  LOCAL FUNCTIONS  ======  LOCAL FUNCTIONS  ============
%==========================================================================================

%==========================================================================================
%     IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT 
%  Descriptions of 2-port structure using "alpha" ( == LWDF.gamma ! no sign-changes, or -1 
%     IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT IMPORTANT 
%==========================================================================================

function outpStr = lfSingleSection1T(fid,wdaChar,inpStr)
	fprintf( fid, 'v1%s = i2%s - %s;\n', wdaChar, wdaChar, inpStr );
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v2%s = %s + m1%s;\n', wdaChar, inpStr, wdaChar );
	fprintf( fid, 'o1%s = v2%s;\n', wdaChar, wdaChar ); 	
	fprintf( fid, 'i2%s = To1%s;\n', wdaChar, wdaChar ); 	
	outpStr = sprintf( 'v3%s', wdaChar );
	fprintf( fid, '%s = i2%s + m1%s;\n\n', outpStr, wdaChar, wdaChar );

function outpStr = lfSingleSection2T(fid,wdaChar,inpStr)
	fprintf( fid, 'v1%s = i2%s - %s;\n', wdaChar, wdaChar, inpStr );
	fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar );
	fprintf( fid, 'v2%s = %s + m1%s;\n', wdaChar, inpStr, wdaChar );
	fprintf( fid, 'o1%s = v2%s;\n', wdaChar, wdaChar ); 	
	fprintf( fid, 'it1%s = To1%s;\n', wdaChar, wdaChar ); 	
	fprintf( fid, 'ot1%s = it1%s;\n', wdaChar, wdaChar ); 	
	fprintf( fid, 'i2%s = Tot1%s;\n', wdaChar, wdaChar ); 	
	outpStr = sprintf( 'v3%s', wdaChar );
	fprintf( fid, '%s = i2%s + m1%s;\n\n', outpStr, wdaChar, wdaChar );

function outpStr = lfDoubleSection1T(fid,dlyLorR,wdaChar,inpStr)
	if ( dlyLorR == 'L' )
		% delay from A1.B2 to A2.A1
		fprintf( fid, 'v1%s = v6%s - %s;\n', wdaChar, wdaChar, inpStr );
		fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'v2%s = %s + m1%s;\n', wdaChar, inpStr, wdaChar );
		fprintf( fid, 'o1%s = v2%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'i2%s = To1%s;\n', wdaChar, wdaChar ); 	
		outpStr = sprintf( 'v3%s', wdaChar );
		fprintf( fid, '%s = v6%s + m1%s;\n', outpStr, wdaChar, wdaChar );
		fprintf( fid, 'v4%s = i3%s - i2%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'm2%s = a2%s * v4%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'v5%s = i2%s + m2%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'o2%s = v5%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'i3%s = To2%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'v6%s = i3%s + m2%s;\n\n', wdaChar, wdaChar, wdaChar );
	else
		% delay from A2.B1 to A1.A2
		fprintf( fid, 'v1%s = i3%s - %s;\n', wdaChar, wdaChar, inpStr );
		fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'v2%s = %s + m1%s;\n', wdaChar, inpStr, wdaChar );
		fprintf( fid, 'v4%s = i2%s - v2%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'm2%s = a2%s * v4%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'v5%s = v2%s + m2%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'o1%s = v5%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'i2%s = To1%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'v6%s = i2%s + m2%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'o2%s = v6%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'i3%s = To2%s;\n', wdaChar, wdaChar ); 	
		outpStr = sprintf( 'v3%s', wdaChar );
		fprintf( fid, '%s = m1%s + i3%s;\n', outpStr, wdaChar, wdaChar );
	end

function outpStr = lfDoubleSection2T(fid,dlyLorR,wdaChar,inpStr)
	if ( dlyLorR == 'L' )
		% delay from A1.B2 to A2.A1
	  	fprintf( fid, 'v1%s = v6%s - %s;\n', wdaChar, wdaChar, inpStr );
		fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'v2%s = %s + m1%s;\n', wdaChar, inpStr, wdaChar );
		fprintf( fid, 'o1%s = v2%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'it1%s = To1%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'ot1%s = it1%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'i2%s = Tot1%s;\n', wdaChar, wdaChar ); 	
		outpStr = sprintf( 'v3%s', wdaChar );
		fprintf( fid, '%s = v6%s + m1%s;\n', outpStr, wdaChar, wdaChar );
		fprintf( fid, 'v4%s = i3%s - i2%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'm2%s = a2%s * v4%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'v5%s = i2%s + m2%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'o2%s = v5%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'it2%s = To2%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'ot2%s = it2%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'i3%s = Tot2%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'v6%s = i3%s + m2%s;\n\n', wdaChar, wdaChar, wdaChar );
	else
		% delay from A2.B1 to A1.A2
	  	fprintf( fid, 'v1%s = v6%s - %s;\n', wdaChar, wdaChar, inpStr );
		fprintf( fid, 'm1%s = a1%s * v1%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'v2%s = %s + m1%s;\n', wdaChar, inpStr, wdaChar );
		fprintf( fid, 'v4%s = i2%s - v2%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'm2%s = a2%s * v4%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'v5%s = v2%s + m2%s;\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'o1%s = v5%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'it1%s = To1%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'ot1%s = it1%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'i2%s = Tot1%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'v6%s = i2%s + m2%s;\n\n', wdaChar, wdaChar, wdaChar );
		fprintf( fid, 'o2%s = v6%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'it2%s = To2%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'ot2%s = it2%s;\n', wdaChar, wdaChar ); 	
		fprintf( fid, 'i3%s = Tot2%s;\n', wdaChar, wdaChar ); 	
		outpStr = sprintf( 'v3%s', wdaChar );
		fprintf( fid, '%s = m1%s + i3%s;\n', outpStr, wdaChar, wdaChar );
	end
	
function outpStr = lfInsertedReg(fid,tbChar,iRegNo,inpStr)
	fprintf( fid, 'or%s%d = %s;\n', tbChar, iRegNo, inpStr );
	outpStr = sprintf( 'ir%s%d', tbChar, iRegNo+1 );
	fprintf( fid, '%s = Tor%s%d;\n\n', outpStr, tbChar, iRegNo );